// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseResult {
    #[prost(int32, tag = "1")]
    pub version: i32,
    #[prost(message, repeated, tag = "2")]
    pub stmts: ::prost::alloc::vec::Vec<RawStmt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanResult {
    #[prost(int32, tag = "1")]
    pub version: i32,
    #[prost(message, repeated, tag = "2")]
    pub tokens: ::prost::alloc::vec::Vec<ScanToken>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(
        oneof = "node::Node",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268"
    )]
    pub node: ::core::option::Option<node::Node>,
}
/// Nested message and enum types in `Node`.
pub mod node {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Node {
        #[prost(message, tag = "1")]
        Alias(super::Alias),
        #[prost(message, tag = "2")]
        RangeVar(super::RangeVar),
        #[prost(message, tag = "3")]
        TableFunc(::prost::alloc::boxed::Box<super::TableFunc>),
        #[prost(message, tag = "4")]
        IntoClause(::prost::alloc::boxed::Box<super::IntoClause>),
        #[prost(message, tag = "5")]
        Var(::prost::alloc::boxed::Box<super::Var>),
        #[prost(message, tag = "6")]
        Param(::prost::alloc::boxed::Box<super::Param>),
        #[prost(message, tag = "7")]
        Aggref(::prost::alloc::boxed::Box<super::Aggref>),
        #[prost(message, tag = "8")]
        GroupingFunc(::prost::alloc::boxed::Box<super::GroupingFunc>),
        #[prost(message, tag = "9")]
        WindowFunc(::prost::alloc::boxed::Box<super::WindowFunc>),
        #[prost(message, tag = "10")]
        WindowFuncRunCondition(
            ::prost::alloc::boxed::Box<super::WindowFuncRunCondition>,
        ),
        #[prost(message, tag = "11")]
        MergeSupportFunc(::prost::alloc::boxed::Box<super::MergeSupportFunc>),
        #[prost(message, tag = "12")]
        SubscriptingRef(::prost::alloc::boxed::Box<super::SubscriptingRef>),
        #[prost(message, tag = "13")]
        FuncExpr(::prost::alloc::boxed::Box<super::FuncExpr>),
        #[prost(message, tag = "14")]
        NamedArgExpr(::prost::alloc::boxed::Box<super::NamedArgExpr>),
        #[prost(message, tag = "15")]
        OpExpr(::prost::alloc::boxed::Box<super::OpExpr>),
        #[prost(message, tag = "16")]
        DistinctExpr(::prost::alloc::boxed::Box<super::DistinctExpr>),
        #[prost(message, tag = "17")]
        NullIfExpr(::prost::alloc::boxed::Box<super::NullIfExpr>),
        #[prost(message, tag = "18")]
        ScalarArrayOpExpr(::prost::alloc::boxed::Box<super::ScalarArrayOpExpr>),
        #[prost(message, tag = "19")]
        BoolExpr(::prost::alloc::boxed::Box<super::BoolExpr>),
        #[prost(message, tag = "20")]
        SubLink(::prost::alloc::boxed::Box<super::SubLink>),
        #[prost(message, tag = "21")]
        SubPlan(::prost::alloc::boxed::Box<super::SubPlan>),
        #[prost(message, tag = "22")]
        AlternativeSubPlan(::prost::alloc::boxed::Box<super::AlternativeSubPlan>),
        #[prost(message, tag = "23")]
        FieldSelect(::prost::alloc::boxed::Box<super::FieldSelect>),
        #[prost(message, tag = "24")]
        FieldStore(::prost::alloc::boxed::Box<super::FieldStore>),
        #[prost(message, tag = "25")]
        RelabelType(::prost::alloc::boxed::Box<super::RelabelType>),
        #[prost(message, tag = "26")]
        CoerceViaIo(::prost::alloc::boxed::Box<super::CoerceViaIo>),
        #[prost(message, tag = "27")]
        ArrayCoerceExpr(::prost::alloc::boxed::Box<super::ArrayCoerceExpr>),
        #[prost(message, tag = "28")]
        ConvertRowtypeExpr(::prost::alloc::boxed::Box<super::ConvertRowtypeExpr>),
        #[prost(message, tag = "29")]
        CollateExpr(::prost::alloc::boxed::Box<super::CollateExpr>),
        #[prost(message, tag = "30")]
        CaseExpr(::prost::alloc::boxed::Box<super::CaseExpr>),
        #[prost(message, tag = "31")]
        CaseWhen(::prost::alloc::boxed::Box<super::CaseWhen>),
        #[prost(message, tag = "32")]
        CaseTestExpr(::prost::alloc::boxed::Box<super::CaseTestExpr>),
        #[prost(message, tag = "33")]
        ArrayExpr(::prost::alloc::boxed::Box<super::ArrayExpr>),
        #[prost(message, tag = "34")]
        RowExpr(::prost::alloc::boxed::Box<super::RowExpr>),
        #[prost(message, tag = "35")]
        RowCompareExpr(::prost::alloc::boxed::Box<super::RowCompareExpr>),
        #[prost(message, tag = "36")]
        CoalesceExpr(::prost::alloc::boxed::Box<super::CoalesceExpr>),
        #[prost(message, tag = "37")]
        MinMaxExpr(::prost::alloc::boxed::Box<super::MinMaxExpr>),
        #[prost(message, tag = "38")]
        SqlvalueFunction(::prost::alloc::boxed::Box<super::SqlValueFunction>),
        #[prost(message, tag = "39")]
        XmlExpr(::prost::alloc::boxed::Box<super::XmlExpr>),
        #[prost(message, tag = "40")]
        JsonFormat(super::JsonFormat),
        #[prost(message, tag = "41")]
        JsonReturning(super::JsonReturning),
        #[prost(message, tag = "42")]
        JsonValueExpr(::prost::alloc::boxed::Box<super::JsonValueExpr>),
        #[prost(message, tag = "43")]
        JsonConstructorExpr(::prost::alloc::boxed::Box<super::JsonConstructorExpr>),
        #[prost(message, tag = "44")]
        JsonIsPredicate(::prost::alloc::boxed::Box<super::JsonIsPredicate>),
        #[prost(message, tag = "45")]
        JsonBehavior(::prost::alloc::boxed::Box<super::JsonBehavior>),
        #[prost(message, tag = "46")]
        JsonExpr(::prost::alloc::boxed::Box<super::JsonExpr>),
        #[prost(message, tag = "47")]
        JsonTablePath(super::JsonTablePath),
        #[prost(message, tag = "48")]
        JsonTablePathScan(::prost::alloc::boxed::Box<super::JsonTablePathScan>),
        #[prost(message, tag = "49")]
        JsonTableSiblingJoin(::prost::alloc::boxed::Box<super::JsonTableSiblingJoin>),
        #[prost(message, tag = "50")]
        NullTest(::prost::alloc::boxed::Box<super::NullTest>),
        #[prost(message, tag = "51")]
        BooleanTest(::prost::alloc::boxed::Box<super::BooleanTest>),
        #[prost(message, tag = "52")]
        MergeAction(::prost::alloc::boxed::Box<super::MergeAction>),
        #[prost(message, tag = "53")]
        CoerceToDomain(::prost::alloc::boxed::Box<super::CoerceToDomain>),
        #[prost(message, tag = "54")]
        CoerceToDomainValue(::prost::alloc::boxed::Box<super::CoerceToDomainValue>),
        #[prost(message, tag = "55")]
        SetToDefault(::prost::alloc::boxed::Box<super::SetToDefault>),
        #[prost(message, tag = "56")]
        CurrentOfExpr(::prost::alloc::boxed::Box<super::CurrentOfExpr>),
        #[prost(message, tag = "57")]
        NextValueExpr(::prost::alloc::boxed::Box<super::NextValueExpr>),
        #[prost(message, tag = "58")]
        InferenceElem(::prost::alloc::boxed::Box<super::InferenceElem>),
        #[prost(message, tag = "59")]
        TargetEntry(::prost::alloc::boxed::Box<super::TargetEntry>),
        #[prost(message, tag = "60")]
        RangeTblRef(super::RangeTblRef),
        #[prost(message, tag = "61")]
        JoinExpr(::prost::alloc::boxed::Box<super::JoinExpr>),
        #[prost(message, tag = "62")]
        FromExpr(::prost::alloc::boxed::Box<super::FromExpr>),
        #[prost(message, tag = "63")]
        OnConflictExpr(::prost::alloc::boxed::Box<super::OnConflictExpr>),
        #[prost(message, tag = "64")]
        Query(::prost::alloc::boxed::Box<super::Query>),
        #[prost(message, tag = "65")]
        TypeName(super::TypeName),
        #[prost(message, tag = "66")]
        ColumnRef(super::ColumnRef),
        #[prost(message, tag = "67")]
        ParamRef(super::ParamRef),
        #[prost(message, tag = "68")]
        AExpr(::prost::alloc::boxed::Box<super::AExpr>),
        #[prost(message, tag = "69")]
        TypeCast(::prost::alloc::boxed::Box<super::TypeCast>),
        #[prost(message, tag = "70")]
        CollateClause(::prost::alloc::boxed::Box<super::CollateClause>),
        #[prost(message, tag = "71")]
        RoleSpec(super::RoleSpec),
        #[prost(message, tag = "72")]
        FuncCall(::prost::alloc::boxed::Box<super::FuncCall>),
        #[prost(message, tag = "73")]
        AStar(super::AStar),
        #[prost(message, tag = "74")]
        AIndices(::prost::alloc::boxed::Box<super::AIndices>),
        #[prost(message, tag = "75")]
        AIndirection(::prost::alloc::boxed::Box<super::AIndirection>),
        #[prost(message, tag = "76")]
        AArrayExpr(super::AArrayExpr),
        #[prost(message, tag = "77")]
        ResTarget(::prost::alloc::boxed::Box<super::ResTarget>),
        #[prost(message, tag = "78")]
        MultiAssignRef(::prost::alloc::boxed::Box<super::MultiAssignRef>),
        #[prost(message, tag = "79")]
        SortBy(::prost::alloc::boxed::Box<super::SortBy>),
        #[prost(message, tag = "80")]
        WindowDef(::prost::alloc::boxed::Box<super::WindowDef>),
        #[prost(message, tag = "81")]
        RangeSubselect(::prost::alloc::boxed::Box<super::RangeSubselect>),
        #[prost(message, tag = "82")]
        RangeFunction(super::RangeFunction),
        #[prost(message, tag = "83")]
        RangeTableFunc(::prost::alloc::boxed::Box<super::RangeTableFunc>),
        #[prost(message, tag = "84")]
        RangeTableFuncCol(::prost::alloc::boxed::Box<super::RangeTableFuncCol>),
        #[prost(message, tag = "85")]
        RangeTableSample(::prost::alloc::boxed::Box<super::RangeTableSample>),
        #[prost(message, tag = "86")]
        ColumnDef(::prost::alloc::boxed::Box<super::ColumnDef>),
        #[prost(message, tag = "87")]
        TableLikeClause(super::TableLikeClause),
        #[prost(message, tag = "88")]
        IndexElem(::prost::alloc::boxed::Box<super::IndexElem>),
        #[prost(message, tag = "89")]
        DefElem(::prost::alloc::boxed::Box<super::DefElem>),
        #[prost(message, tag = "90")]
        LockingClause(super::LockingClause),
        #[prost(message, tag = "91")]
        XmlSerialize(::prost::alloc::boxed::Box<super::XmlSerialize>),
        #[prost(message, tag = "92")]
        PartitionElem(::prost::alloc::boxed::Box<super::PartitionElem>),
        #[prost(message, tag = "93")]
        PartitionSpec(super::PartitionSpec),
        #[prost(message, tag = "94")]
        PartitionBoundSpec(super::PartitionBoundSpec),
        #[prost(message, tag = "95")]
        PartitionRangeDatum(::prost::alloc::boxed::Box<super::PartitionRangeDatum>),
        #[prost(message, tag = "96")]
        SinglePartitionSpec(super::SinglePartitionSpec),
        #[prost(message, tag = "97")]
        PartitionCmd(super::PartitionCmd),
        #[prost(message, tag = "98")]
        RangeTblEntry(::prost::alloc::boxed::Box<super::RangeTblEntry>),
        #[prost(message, tag = "99")]
        RtepermissionInfo(super::RtePermissionInfo),
        #[prost(message, tag = "100")]
        RangeTblFunction(::prost::alloc::boxed::Box<super::RangeTblFunction>),
        #[prost(message, tag = "101")]
        TableSampleClause(::prost::alloc::boxed::Box<super::TableSampleClause>),
        #[prost(message, tag = "102")]
        WithCheckOption(::prost::alloc::boxed::Box<super::WithCheckOption>),
        #[prost(message, tag = "103")]
        SortGroupClause(super::SortGroupClause),
        #[prost(message, tag = "104")]
        GroupingSet(super::GroupingSet),
        #[prost(message, tag = "105")]
        WindowClause(::prost::alloc::boxed::Box<super::WindowClause>),
        #[prost(message, tag = "106")]
        RowMarkClause(super::RowMarkClause),
        #[prost(message, tag = "107")]
        WithClause(super::WithClause),
        #[prost(message, tag = "108")]
        InferClause(::prost::alloc::boxed::Box<super::InferClause>),
        #[prost(message, tag = "109")]
        OnConflictClause(::prost::alloc::boxed::Box<super::OnConflictClause>),
        #[prost(message, tag = "110")]
        CtesearchClause(super::CteSearchClause),
        #[prost(message, tag = "111")]
        CtecycleClause(::prost::alloc::boxed::Box<super::CteCycleClause>),
        #[prost(message, tag = "112")]
        CommonTableExpr(::prost::alloc::boxed::Box<super::CommonTableExpr>),
        #[prost(message, tag = "113")]
        MergeWhenClause(::prost::alloc::boxed::Box<super::MergeWhenClause>),
        #[prost(message, tag = "114")]
        TriggerTransition(super::TriggerTransition),
        #[prost(message, tag = "115")]
        JsonOutput(super::JsonOutput),
        #[prost(message, tag = "116")]
        JsonArgument(::prost::alloc::boxed::Box<super::JsonArgument>),
        #[prost(message, tag = "117")]
        JsonFuncExpr(::prost::alloc::boxed::Box<super::JsonFuncExpr>),
        #[prost(message, tag = "118")]
        JsonTablePathSpec(::prost::alloc::boxed::Box<super::JsonTablePathSpec>),
        #[prost(message, tag = "119")]
        JsonTable(::prost::alloc::boxed::Box<super::JsonTable>),
        #[prost(message, tag = "120")]
        JsonTableColumn(::prost::alloc::boxed::Box<super::JsonTableColumn>),
        #[prost(message, tag = "121")]
        JsonKeyValue(::prost::alloc::boxed::Box<super::JsonKeyValue>),
        #[prost(message, tag = "122")]
        JsonParseExpr(::prost::alloc::boxed::Box<super::JsonParseExpr>),
        #[prost(message, tag = "123")]
        JsonScalarExpr(::prost::alloc::boxed::Box<super::JsonScalarExpr>),
        #[prost(message, tag = "124")]
        JsonSerializeExpr(::prost::alloc::boxed::Box<super::JsonSerializeExpr>),
        #[prost(message, tag = "125")]
        JsonObjectConstructor(super::JsonObjectConstructor),
        #[prost(message, tag = "126")]
        JsonArrayConstructor(super::JsonArrayConstructor),
        #[prost(message, tag = "127")]
        JsonArrayQueryConstructor(
            ::prost::alloc::boxed::Box<super::JsonArrayQueryConstructor>,
        ),
        #[prost(message, tag = "128")]
        JsonAggConstructor(::prost::alloc::boxed::Box<super::JsonAggConstructor>),
        #[prost(message, tag = "129")]
        JsonObjectAgg(::prost::alloc::boxed::Box<super::JsonObjectAgg>),
        #[prost(message, tag = "130")]
        JsonArrayAgg(::prost::alloc::boxed::Box<super::JsonArrayAgg>),
        #[prost(message, tag = "131")]
        RawStmt(::prost::alloc::boxed::Box<super::RawStmt>),
        #[prost(message, tag = "132")]
        InsertStmt(::prost::alloc::boxed::Box<super::InsertStmt>),
        #[prost(message, tag = "133")]
        DeleteStmt(::prost::alloc::boxed::Box<super::DeleteStmt>),
        #[prost(message, tag = "134")]
        UpdateStmt(::prost::alloc::boxed::Box<super::UpdateStmt>),
        #[prost(message, tag = "135")]
        MergeStmt(::prost::alloc::boxed::Box<super::MergeStmt>),
        #[prost(message, tag = "136")]
        SelectStmt(::prost::alloc::boxed::Box<super::SelectStmt>),
        #[prost(message, tag = "137")]
        SetOperationStmt(::prost::alloc::boxed::Box<super::SetOperationStmt>),
        #[prost(message, tag = "138")]
        ReturnStmt(::prost::alloc::boxed::Box<super::ReturnStmt>),
        #[prost(message, tag = "139")]
        PlassignStmt(::prost::alloc::boxed::Box<super::PlAssignStmt>),
        #[prost(message, tag = "140")]
        CreateSchemaStmt(super::CreateSchemaStmt),
        #[prost(message, tag = "141")]
        AlterTableStmt(super::AlterTableStmt),
        #[prost(message, tag = "142")]
        ReplicaIdentityStmt(super::ReplicaIdentityStmt),
        #[prost(message, tag = "143")]
        AlterTableCmd(::prost::alloc::boxed::Box<super::AlterTableCmd>),
        #[prost(message, tag = "144")]
        AlterCollationStmt(super::AlterCollationStmt),
        #[prost(message, tag = "145")]
        AlterDomainStmt(::prost::alloc::boxed::Box<super::AlterDomainStmt>),
        #[prost(message, tag = "146")]
        GrantStmt(super::GrantStmt),
        #[prost(message, tag = "147")]
        ObjectWithArgs(super::ObjectWithArgs),
        #[prost(message, tag = "148")]
        AccessPriv(super::AccessPriv),
        #[prost(message, tag = "149")]
        GrantRoleStmt(super::GrantRoleStmt),
        #[prost(message, tag = "150")]
        AlterDefaultPrivilegesStmt(super::AlterDefaultPrivilegesStmt),
        #[prost(message, tag = "151")]
        CopyStmt(::prost::alloc::boxed::Box<super::CopyStmt>),
        #[prost(message, tag = "152")]
        VariableSetStmt(super::VariableSetStmt),
        #[prost(message, tag = "153")]
        VariableShowStmt(super::VariableShowStmt),
        #[prost(message, tag = "154")]
        CreateStmt(super::CreateStmt),
        #[prost(message, tag = "155")]
        Constraint(::prost::alloc::boxed::Box<super::Constraint>),
        #[prost(message, tag = "156")]
        CreateTableSpaceStmt(super::CreateTableSpaceStmt),
        #[prost(message, tag = "157")]
        DropTableSpaceStmt(super::DropTableSpaceStmt),
        #[prost(message, tag = "158")]
        AlterTableSpaceOptionsStmt(super::AlterTableSpaceOptionsStmt),
        #[prost(message, tag = "159")]
        AlterTableMoveAllStmt(super::AlterTableMoveAllStmt),
        #[prost(message, tag = "160")]
        CreateExtensionStmt(super::CreateExtensionStmt),
        #[prost(message, tag = "161")]
        AlterExtensionStmt(super::AlterExtensionStmt),
        #[prost(message, tag = "162")]
        AlterExtensionContentsStmt(
            ::prost::alloc::boxed::Box<super::AlterExtensionContentsStmt>,
        ),
        #[prost(message, tag = "163")]
        CreateFdwStmt(super::CreateFdwStmt),
        #[prost(message, tag = "164")]
        AlterFdwStmt(super::AlterFdwStmt),
        #[prost(message, tag = "165")]
        CreateForeignServerStmt(super::CreateForeignServerStmt),
        #[prost(message, tag = "166")]
        AlterForeignServerStmt(super::AlterForeignServerStmt),
        #[prost(message, tag = "167")]
        CreateForeignTableStmt(super::CreateForeignTableStmt),
        #[prost(message, tag = "168")]
        CreateUserMappingStmt(super::CreateUserMappingStmt),
        #[prost(message, tag = "169")]
        AlterUserMappingStmt(super::AlterUserMappingStmt),
        #[prost(message, tag = "170")]
        DropUserMappingStmt(super::DropUserMappingStmt),
        #[prost(message, tag = "171")]
        ImportForeignSchemaStmt(super::ImportForeignSchemaStmt),
        #[prost(message, tag = "172")]
        CreatePolicyStmt(::prost::alloc::boxed::Box<super::CreatePolicyStmt>),
        #[prost(message, tag = "173")]
        AlterPolicyStmt(::prost::alloc::boxed::Box<super::AlterPolicyStmt>),
        #[prost(message, tag = "174")]
        CreateAmStmt(super::CreateAmStmt),
        #[prost(message, tag = "175")]
        CreateTrigStmt(::prost::alloc::boxed::Box<super::CreateTrigStmt>),
        #[prost(message, tag = "176")]
        CreateEventTrigStmt(super::CreateEventTrigStmt),
        #[prost(message, tag = "177")]
        AlterEventTrigStmt(super::AlterEventTrigStmt),
        #[prost(message, tag = "178")]
        CreatePlangStmt(super::CreatePLangStmt),
        #[prost(message, tag = "179")]
        CreateRoleStmt(super::CreateRoleStmt),
        #[prost(message, tag = "180")]
        AlterRoleStmt(super::AlterRoleStmt),
        #[prost(message, tag = "181")]
        AlterRoleSetStmt(super::AlterRoleSetStmt),
        #[prost(message, tag = "182")]
        DropRoleStmt(super::DropRoleStmt),
        #[prost(message, tag = "183")]
        CreateSeqStmt(super::CreateSeqStmt),
        #[prost(message, tag = "184")]
        AlterSeqStmt(super::AlterSeqStmt),
        #[prost(message, tag = "185")]
        DefineStmt(super::DefineStmt),
        #[prost(message, tag = "186")]
        CreateDomainStmt(::prost::alloc::boxed::Box<super::CreateDomainStmt>),
        #[prost(message, tag = "187")]
        CreateOpClassStmt(super::CreateOpClassStmt),
        #[prost(message, tag = "188")]
        CreateOpClassItem(super::CreateOpClassItem),
        #[prost(message, tag = "189")]
        CreateOpFamilyStmt(super::CreateOpFamilyStmt),
        #[prost(message, tag = "190")]
        AlterOpFamilyStmt(super::AlterOpFamilyStmt),
        #[prost(message, tag = "191")]
        DropStmt(super::DropStmt),
        #[prost(message, tag = "192")]
        TruncateStmt(super::TruncateStmt),
        #[prost(message, tag = "193")]
        CommentStmt(::prost::alloc::boxed::Box<super::CommentStmt>),
        #[prost(message, tag = "194")]
        SecLabelStmt(::prost::alloc::boxed::Box<super::SecLabelStmt>),
        #[prost(message, tag = "195")]
        DeclareCursorStmt(::prost::alloc::boxed::Box<super::DeclareCursorStmt>),
        #[prost(message, tag = "196")]
        ClosePortalStmt(super::ClosePortalStmt),
        #[prost(message, tag = "197")]
        FetchStmt(super::FetchStmt),
        #[prost(message, tag = "198")]
        IndexStmt(::prost::alloc::boxed::Box<super::IndexStmt>),
        #[prost(message, tag = "199")]
        CreateStatsStmt(super::CreateStatsStmt),
        #[prost(message, tag = "200")]
        StatsElem(::prost::alloc::boxed::Box<super::StatsElem>),
        #[prost(message, tag = "201")]
        AlterStatsStmt(::prost::alloc::boxed::Box<super::AlterStatsStmt>),
        #[prost(message, tag = "202")]
        CreateFunctionStmt(::prost::alloc::boxed::Box<super::CreateFunctionStmt>),
        #[prost(message, tag = "203")]
        FunctionParameter(::prost::alloc::boxed::Box<super::FunctionParameter>),
        #[prost(message, tag = "204")]
        AlterFunctionStmt(super::AlterFunctionStmt),
        #[prost(message, tag = "205")]
        DoStmt(super::DoStmt),
        #[prost(message, tag = "206")]
        InlineCodeBlock(super::InlineCodeBlock),
        #[prost(message, tag = "207")]
        CallStmt(::prost::alloc::boxed::Box<super::CallStmt>),
        #[prost(message, tag = "208")]
        CallContext(super::CallContext),
        #[prost(message, tag = "209")]
        RenameStmt(::prost::alloc::boxed::Box<super::RenameStmt>),
        #[prost(message, tag = "210")]
        AlterObjectDependsStmt(
            ::prost::alloc::boxed::Box<super::AlterObjectDependsStmt>,
        ),
        #[prost(message, tag = "211")]
        AlterObjectSchemaStmt(::prost::alloc::boxed::Box<super::AlterObjectSchemaStmt>),
        #[prost(message, tag = "212")]
        AlterOwnerStmt(::prost::alloc::boxed::Box<super::AlterOwnerStmt>),
        #[prost(message, tag = "213")]
        AlterOperatorStmt(super::AlterOperatorStmt),
        #[prost(message, tag = "214")]
        AlterTypeStmt(super::AlterTypeStmt),
        #[prost(message, tag = "215")]
        RuleStmt(::prost::alloc::boxed::Box<super::RuleStmt>),
        #[prost(message, tag = "216")]
        NotifyStmt(super::NotifyStmt),
        #[prost(message, tag = "217")]
        ListenStmt(super::ListenStmt),
        #[prost(message, tag = "218")]
        UnlistenStmt(super::UnlistenStmt),
        #[prost(message, tag = "219")]
        TransactionStmt(super::TransactionStmt),
        #[prost(message, tag = "220")]
        CompositeTypeStmt(super::CompositeTypeStmt),
        #[prost(message, tag = "221")]
        CreateEnumStmt(super::CreateEnumStmt),
        #[prost(message, tag = "222")]
        CreateRangeStmt(super::CreateRangeStmt),
        #[prost(message, tag = "223")]
        AlterEnumStmt(super::AlterEnumStmt),
        #[prost(message, tag = "224")]
        ViewStmt(::prost::alloc::boxed::Box<super::ViewStmt>),
        #[prost(message, tag = "225")]
        LoadStmt(super::LoadStmt),
        #[prost(message, tag = "226")]
        CreatedbStmt(super::CreatedbStmt),
        #[prost(message, tag = "227")]
        AlterDatabaseStmt(super::AlterDatabaseStmt),
        #[prost(message, tag = "228")]
        AlterDatabaseRefreshCollStmt(super::AlterDatabaseRefreshCollStmt),
        #[prost(message, tag = "229")]
        AlterDatabaseSetStmt(super::AlterDatabaseSetStmt),
        #[prost(message, tag = "230")]
        DropdbStmt(super::DropdbStmt),
        #[prost(message, tag = "231")]
        AlterSystemStmt(super::AlterSystemStmt),
        #[prost(message, tag = "232")]
        ClusterStmt(super::ClusterStmt),
        #[prost(message, tag = "233")]
        VacuumStmt(super::VacuumStmt),
        #[prost(message, tag = "234")]
        VacuumRelation(super::VacuumRelation),
        #[prost(message, tag = "235")]
        ExplainStmt(::prost::alloc::boxed::Box<super::ExplainStmt>),
        #[prost(message, tag = "236")]
        CreateTableAsStmt(::prost::alloc::boxed::Box<super::CreateTableAsStmt>),
        #[prost(message, tag = "237")]
        RefreshMatViewStmt(super::RefreshMatViewStmt),
        #[prost(message, tag = "238")]
        CheckPointStmt(super::CheckPointStmt),
        #[prost(message, tag = "239")]
        DiscardStmt(super::DiscardStmt),
        #[prost(message, tag = "240")]
        LockStmt(super::LockStmt),
        #[prost(message, tag = "241")]
        ConstraintsSetStmt(super::ConstraintsSetStmt),
        #[prost(message, tag = "242")]
        ReindexStmt(super::ReindexStmt),
        #[prost(message, tag = "243")]
        CreateConversionStmt(super::CreateConversionStmt),
        #[prost(message, tag = "244")]
        CreateCastStmt(super::CreateCastStmt),
        #[prost(message, tag = "245")]
        CreateTransformStmt(super::CreateTransformStmt),
        #[prost(message, tag = "246")]
        PrepareStmt(::prost::alloc::boxed::Box<super::PrepareStmt>),
        #[prost(message, tag = "247")]
        ExecuteStmt(super::ExecuteStmt),
        #[prost(message, tag = "248")]
        DeallocateStmt(super::DeallocateStmt),
        #[prost(message, tag = "249")]
        DropOwnedStmt(super::DropOwnedStmt),
        #[prost(message, tag = "250")]
        ReassignOwnedStmt(super::ReassignOwnedStmt),
        #[prost(message, tag = "251")]
        AlterTsdictionaryStmt(super::AlterTsDictionaryStmt),
        #[prost(message, tag = "252")]
        AlterTsconfigurationStmt(super::AlterTsConfigurationStmt),
        #[prost(message, tag = "253")]
        PublicationTable(::prost::alloc::boxed::Box<super::PublicationTable>),
        #[prost(message, tag = "254")]
        PublicationObjSpec(::prost::alloc::boxed::Box<super::PublicationObjSpec>),
        #[prost(message, tag = "255")]
        CreatePublicationStmt(super::CreatePublicationStmt),
        #[prost(message, tag = "256")]
        AlterPublicationStmt(super::AlterPublicationStmt),
        #[prost(message, tag = "257")]
        CreateSubscriptionStmt(super::CreateSubscriptionStmt),
        #[prost(message, tag = "258")]
        AlterSubscriptionStmt(super::AlterSubscriptionStmt),
        #[prost(message, tag = "259")]
        DropSubscriptionStmt(super::DropSubscriptionStmt),
        #[prost(message, tag = "260")]
        Integer(super::Integer),
        #[prost(message, tag = "261")]
        Float(super::Float),
        #[prost(message, tag = "262")]
        Boolean(super::Boolean),
        #[prost(message, tag = "263")]
        String(super::String),
        #[prost(message, tag = "264")]
        BitString(super::BitString),
        #[prost(message, tag = "265")]
        List(super::List),
        #[prost(message, tag = "266")]
        IntList(super::IntList),
        #[prost(message, tag = "267")]
        OidList(super::OidList),
        #[prost(message, tag = "268")]
        AConst(super::AConst),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Integer {
    /// machine integer
    #[prost(int32, tag = "1")]
    pub ival: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Float {
    /// string
    #[prost(string, tag = "1")]
    pub fval: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Boolean {
    #[prost(bool, tag = "1")]
    pub boolval: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct String {
    /// string
    #[prost(string, tag = "1")]
    pub sval: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BitString {
    /// string
    #[prost(string, tag = "1")]
    pub bsval: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct List {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OidList {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntList {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AConst {
    #[prost(bool, tag = "10")]
    pub isnull: bool,
    #[prost(int32, tag = "11")]
    pub location: i32,
    #[prost(oneof = "a_const::Val", tags = "1, 2, 3, 4, 5")]
    pub val: ::core::option::Option<a_const::Val>,
}
/// Nested message and enum types in `A_Const`.
pub mod a_const {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Val {
        #[prost(message, tag = "1")]
        Ival(super::Integer),
        #[prost(message, tag = "2")]
        Fval(super::Float),
        #[prost(message, tag = "3")]
        Boolval(super::Boolean),
        #[prost(message, tag = "4")]
        Sval(super::String),
        #[prost(message, tag = "5")]
        Bsval(super::BitString),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alias {
    #[prost(string, tag = "1")]
    pub aliasname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub colnames: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeVar {
    #[prost(string, tag = "1")]
    pub catalogname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub schemaname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub relname: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub inh: bool,
    #[prost(string, tag = "5")]
    pub relpersistence: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub alias: ::core::option::Option<Alias>,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableFunc {
    #[prost(enumeration = "TableFuncType", tag = "1")]
    pub functype: i32,
    #[prost(message, repeated, tag = "2")]
    pub ns_uris: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub ns_names: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub docexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "5")]
    pub rowexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "6")]
    pub colnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "7")]
    pub coltypes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "8")]
    pub coltypmods: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "9")]
    pub colcollations: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "10")]
    pub colexprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "11")]
    pub coldefexprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "12")]
    pub colvalexprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "13")]
    pub passingvalexprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint64, repeated, tag = "14")]
    pub notnulls: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, optional, boxed, tag = "15")]
    pub plan: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "16")]
    pub ordinalitycol: i32,
    #[prost(int32, tag = "17")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntoClause {
    #[prost(message, optional, tag = "1")]
    pub rel: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub col_names: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "3")]
    pub access_method: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "OnCommitAction", tag = "5")]
    pub on_commit: i32,
    #[prost(string, tag = "6")]
    pub table_space_name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "7")]
    pub view_query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(bool, tag = "8")]
    pub skip_data: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Var {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "2")]
    pub varno: i32,
    #[prost(int32, tag = "3")]
    pub varattno: i32,
    #[prost(uint32, tag = "4")]
    pub vartype: u32,
    #[prost(int32, tag = "5")]
    pub vartypmod: i32,
    #[prost(uint32, tag = "6")]
    pub varcollid: u32,
    #[prost(uint64, repeated, tag = "7")]
    pub varnullingrels: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "8")]
    pub varlevelsup: u32,
    #[prost(int32, tag = "9")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Param {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "ParamKind", tag = "2")]
    pub paramkind: i32,
    #[prost(int32, tag = "3")]
    pub paramid: i32,
    #[prost(uint32, tag = "4")]
    pub paramtype: u32,
    #[prost(int32, tag = "5")]
    pub paramtypmod: i32,
    #[prost(uint32, tag = "6")]
    pub paramcollid: u32,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aggref {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub aggfnoid: u32,
    #[prost(uint32, tag = "3")]
    pub aggtype: u32,
    #[prost(uint32, tag = "4")]
    pub aggcollid: u32,
    #[prost(uint32, tag = "5")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "6")]
    pub aggargtypes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "7")]
    pub aggdirectargs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "8")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "9")]
    pub aggorder: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "10")]
    pub aggdistinct: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "11")]
    pub aggfilter: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(bool, tag = "12")]
    pub aggstar: bool,
    #[prost(bool, tag = "13")]
    pub aggvariadic: bool,
    #[prost(string, tag = "14")]
    pub aggkind: ::prost::alloc::string::String,
    #[prost(uint32, tag = "15")]
    pub agglevelsup: u32,
    #[prost(enumeration = "AggSplit", tag = "16")]
    pub aggsplit: i32,
    #[prost(int32, tag = "17")]
    pub aggno: i32,
    #[prost(int32, tag = "18")]
    pub aggtransno: i32,
    #[prost(int32, tag = "19")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupingFunc {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub refs: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "4")]
    pub agglevelsup: u32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowFunc {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub winfnoid: u32,
    #[prost(uint32, tag = "3")]
    pub wintype: u32,
    #[prost(uint32, tag = "4")]
    pub wincollid: u32,
    #[prost(uint32, tag = "5")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "7")]
    pub aggfilter: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "8")]
    pub run_condition: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "9")]
    pub winref: u32,
    #[prost(bool, tag = "10")]
    pub winstar: bool,
    #[prost(bool, tag = "11")]
    pub winagg: bool,
    #[prost(int32, tag = "12")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowFuncRunCondition {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub opno: u32,
    #[prost(uint32, tag = "3")]
    pub inputcollid: u32,
    #[prost(bool, tag = "4")]
    pub wfunc_left: bool,
    #[prost(message, optional, boxed, tag = "5")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeSupportFunc {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub msftype: u32,
    #[prost(uint32, tag = "3")]
    pub msfcollid: u32,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptingRef {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub refcontainertype: u32,
    #[prost(uint32, tag = "3")]
    pub refelemtype: u32,
    #[prost(uint32, tag = "4")]
    pub refrestype: u32,
    #[prost(int32, tag = "5")]
    pub reftypmod: i32,
    #[prost(uint32, tag = "6")]
    pub refcollid: u32,
    #[prost(message, repeated, tag = "7")]
    pub refupperindexpr: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "8")]
    pub reflowerindexpr: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "9")]
    pub refexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "10")]
    pub refassgnexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FuncExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub funcid: u32,
    #[prost(uint32, tag = "3")]
    pub funcresulttype: u32,
    #[prost(bool, tag = "4")]
    pub funcretset: bool,
    #[prost(bool, tag = "5")]
    pub funcvariadic: bool,
    #[prost(enumeration = "CoercionForm", tag = "6")]
    pub funcformat: i32,
    #[prost(uint32, tag = "7")]
    pub funccollid: u32,
    #[prost(uint32, tag = "8")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "9")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "10")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamedArgExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub argnumber: i32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub opno: u32,
    #[prost(uint32, tag = "3")]
    pub opresulttype: u32,
    #[prost(bool, tag = "4")]
    pub opretset: bool,
    #[prost(uint32, tag = "5")]
    pub opcollid: u32,
    #[prost(uint32, tag = "6")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistinctExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub opno: u32,
    #[prost(uint32, tag = "3")]
    pub opresulttype: u32,
    #[prost(bool, tag = "4")]
    pub opretset: bool,
    #[prost(uint32, tag = "5")]
    pub opcollid: u32,
    #[prost(uint32, tag = "6")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NullIfExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub opno: u32,
    #[prost(uint32, tag = "3")]
    pub opresulttype: u32,
    #[prost(bool, tag = "4")]
    pub opretset: bool,
    #[prost(uint32, tag = "5")]
    pub opcollid: u32,
    #[prost(uint32, tag = "6")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarArrayOpExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub opno: u32,
    #[prost(bool, tag = "3")]
    pub use_or: bool,
    #[prost(uint32, tag = "4")]
    pub inputcollid: u32,
    #[prost(message, repeated, tag = "5")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "6")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "BoolExprType", tag = "2")]
    pub boolop: i32,
    #[prost(message, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubLink {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "SubLinkType", tag = "2")]
    pub sub_link_type: i32,
    #[prost(int32, tag = "3")]
    pub sub_link_id: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub testexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub oper_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "6")]
    pub subselect: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubPlan {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "SubLinkType", tag = "2")]
    pub sub_link_type: i32,
    #[prost(message, optional, boxed, tag = "3")]
    pub testexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "4")]
    pub param_ids: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "5")]
    pub plan_id: i32,
    #[prost(string, tag = "6")]
    pub plan_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "7")]
    pub first_col_type: u32,
    #[prost(int32, tag = "8")]
    pub first_col_typmod: i32,
    #[prost(uint32, tag = "9")]
    pub first_col_collation: u32,
    #[prost(bool, tag = "10")]
    pub use_hash_table: bool,
    #[prost(bool, tag = "11")]
    pub unknown_eq_false: bool,
    #[prost(bool, tag = "12")]
    pub parallel_safe: bool,
    #[prost(message, repeated, tag = "13")]
    pub set_param: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "14")]
    pub par_param: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "15")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(double, tag = "16")]
    pub startup_cost: f64,
    #[prost(double, tag = "17")]
    pub per_call_cost: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlternativeSubPlan {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub subplans: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldSelect {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "3")]
    pub fieldnum: i32,
    #[prost(uint32, tag = "4")]
    pub resulttype: u32,
    #[prost(int32, tag = "5")]
    pub resulttypmod: i32,
    #[prost(uint32, tag = "6")]
    pub resultcollid: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldStore {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "3")]
    pub newvals: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub fieldnums: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "5")]
    pub resulttype: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelabelType {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "3")]
    pub resulttype: u32,
    #[prost(int32, tag = "4")]
    pub resulttypmod: i32,
    #[prost(uint32, tag = "5")]
    pub resultcollid: u32,
    #[prost(enumeration = "CoercionForm", tag = "6")]
    pub relabelformat: i32,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoerceViaIo {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "3")]
    pub resulttype: u32,
    #[prost(uint32, tag = "4")]
    pub resultcollid: u32,
    #[prost(enumeration = "CoercionForm", tag = "5")]
    pub coerceformat: i32,
    #[prost(int32, tag = "6")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayCoerceExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "3")]
    pub elemexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "4")]
    pub resulttype: u32,
    #[prost(int32, tag = "5")]
    pub resulttypmod: i32,
    #[prost(uint32, tag = "6")]
    pub resultcollid: u32,
    #[prost(enumeration = "CoercionForm", tag = "7")]
    pub coerceformat: i32,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertRowtypeExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "3")]
    pub resulttype: u32,
    #[prost(enumeration = "CoercionForm", tag = "4")]
    pub convertformat: i32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollateExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "3")]
    pub coll_oid: u32,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaseExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub casetype: u32,
    #[prost(uint32, tag = "3")]
    pub casecollid: u32,
    #[prost(message, optional, boxed, tag = "4")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "6")]
    pub defresult: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaseWhen {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "3")]
    pub result: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaseTestExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub type_id: u32,
    #[prost(int32, tag = "3")]
    pub type_mod: i32,
    #[prost(uint32, tag = "4")]
    pub collation: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub array_typeid: u32,
    #[prost(uint32, tag = "3")]
    pub array_collid: u32,
    #[prost(uint32, tag = "4")]
    pub element_typeid: u32,
    #[prost(message, repeated, tag = "5")]
    pub elements: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "6")]
    pub multidims: bool,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "3")]
    pub row_typeid: u32,
    #[prost(enumeration = "CoercionForm", tag = "4")]
    pub row_format: i32,
    #[prost(message, repeated, tag = "5")]
    pub colnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "6")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowCompareExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "RowCompareType", tag = "2")]
    pub rctype: i32,
    #[prost(message, repeated, tag = "3")]
    pub opnos: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub opfamilies: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub inputcollids: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub largs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "7")]
    pub rargs: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoalesceExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub coalescetype: u32,
    #[prost(uint32, tag = "3")]
    pub coalescecollid: u32,
    #[prost(message, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinMaxExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub minmaxtype: u32,
    #[prost(uint32, tag = "3")]
    pub minmaxcollid: u32,
    #[prost(uint32, tag = "4")]
    pub inputcollid: u32,
    #[prost(enumeration = "MinMaxOp", tag = "5")]
    pub op: i32,
    #[prost(message, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlValueFunction {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "SqlValueFunctionOp", tag = "2")]
    pub op: i32,
    #[prost(uint32, tag = "3")]
    pub r#type: u32,
    #[prost(int32, tag = "4")]
    pub typmod: i32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XmlExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "XmlExprOp", tag = "2")]
    pub op: i32,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub named_args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub arg_names: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "XmlOptionType", tag = "7")]
    pub xmloption: i32,
    #[prost(bool, tag = "8")]
    pub indent: bool,
    #[prost(uint32, tag = "9")]
    pub r#type: u32,
    #[prost(int32, tag = "10")]
    pub typmod: i32,
    #[prost(int32, tag = "11")]
    pub location: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JsonFormat {
    #[prost(enumeration = "JsonFormatType", tag = "1")]
    pub format_type: i32,
    #[prost(enumeration = "JsonEncoding", tag = "2")]
    pub encoding: i32,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JsonReturning {
    #[prost(message, optional, tag = "1")]
    pub format: ::core::option::Option<JsonFormat>,
    #[prost(uint32, tag = "2")]
    pub typid: u32,
    #[prost(int32, tag = "3")]
    pub typmod: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonValueExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub raw_expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub formatted_expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "3")]
    pub format: ::core::option::Option<JsonFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonConstructorExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "JsonConstructorType", tag = "2")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub func: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "5")]
    pub coercion: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "6")]
    pub returning: ::core::option::Option<JsonReturning>,
    #[prost(bool, tag = "7")]
    pub absent_on_null: bool,
    #[prost(bool, tag = "8")]
    pub unique: bool,
    #[prost(int32, tag = "9")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonIsPredicate {
    #[prost(message, optional, boxed, tag = "1")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "2")]
    pub format: ::core::option::Option<JsonFormat>,
    #[prost(enumeration = "JsonValueType", tag = "3")]
    pub item_type: i32,
    #[prost(bool, tag = "4")]
    pub unique_keys: bool,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonBehavior {
    #[prost(enumeration = "JsonBehaviorType", tag = "1")]
    pub btype: i32,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(bool, tag = "3")]
    pub coerce: bool,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "JsonExprOp", tag = "2")]
    pub op: i32,
    #[prost(string, tag = "3")]
    pub column_name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "4")]
    pub formatted_expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "5")]
    pub format: ::core::option::Option<JsonFormat>,
    #[prost(message, optional, boxed, tag = "6")]
    pub path_spec: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "7")]
    pub returning: ::core::option::Option<JsonReturning>,
    #[prost(message, repeated, tag = "8")]
    pub passing_names: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "9")]
    pub passing_values: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "10")]
    pub on_empty: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(message, optional, boxed, tag = "11")]
    pub on_error: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(bool, tag = "12")]
    pub use_io_coercion: bool,
    #[prost(bool, tag = "13")]
    pub use_json_coercion: bool,
    #[prost(enumeration = "JsonWrapper", tag = "14")]
    pub wrapper: i32,
    #[prost(bool, tag = "15")]
    pub omit_quotes: bool,
    #[prost(uint32, tag = "16")]
    pub collation: u32,
    #[prost(int32, tag = "17")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonTablePath {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonTablePathScan {
    #[prost(message, optional, boxed, tag = "1")]
    pub plan: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "2")]
    pub path: ::core::option::Option<JsonTablePath>,
    #[prost(bool, tag = "3")]
    pub error_on_error: bool,
    #[prost(message, optional, boxed, tag = "4")]
    pub child: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "5")]
    pub col_min: i32,
    #[prost(int32, tag = "6")]
    pub col_max: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonTableSiblingJoin {
    #[prost(message, optional, boxed, tag = "1")]
    pub plan: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub lplan: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "3")]
    pub rplan: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NullTest {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "NullTestType", tag = "3")]
    pub nulltesttype: i32,
    #[prost(bool, tag = "4")]
    pub argisrow: bool,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BooleanTest {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "BoolTestType", tag = "3")]
    pub booltesttype: i32,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeAction {
    #[prost(enumeration = "MergeMatchKind", tag = "1")]
    pub match_kind: i32,
    #[prost(enumeration = "CmdType", tag = "2")]
    pub command_type: i32,
    #[prost(enumeration = "OverridingKind", tag = "3")]
    pub r#override: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub qual: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub target_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub update_colnos: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoerceToDomain {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "3")]
    pub resulttype: u32,
    #[prost(int32, tag = "4")]
    pub resulttypmod: i32,
    #[prost(uint32, tag = "5")]
    pub resultcollid: u32,
    #[prost(enumeration = "CoercionForm", tag = "6")]
    pub coercionformat: i32,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoerceToDomainValue {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub type_id: u32,
    #[prost(int32, tag = "3")]
    pub type_mod: i32,
    #[prost(uint32, tag = "4")]
    pub collation: u32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetToDefault {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub type_id: u32,
    #[prost(int32, tag = "3")]
    pub type_mod: i32,
    #[prost(uint32, tag = "4")]
    pub collation: u32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrentOfExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub cvarno: u32,
    #[prost(string, tag = "3")]
    pub cursor_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub cursor_param: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NextValueExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "2")]
    pub seqid: u32,
    #[prost(uint32, tag = "3")]
    pub type_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InferenceElem {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "3")]
    pub infercollid: u32,
    #[prost(uint32, tag = "4")]
    pub inferopclass: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetEntry {
    #[prost(message, optional, boxed, tag = "1")]
    pub xpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "3")]
    pub resno: i32,
    #[prost(string, tag = "4")]
    pub resname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub ressortgroupref: u32,
    #[prost(uint32, tag = "6")]
    pub resorigtbl: u32,
    #[prost(int32, tag = "7")]
    pub resorigcol: i32,
    #[prost(bool, tag = "8")]
    pub resjunk: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RangeTblRef {
    #[prost(int32, tag = "1")]
    pub rtindex: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinExpr {
    #[prost(enumeration = "JoinType", tag = "1")]
    pub jointype: i32,
    #[prost(bool, tag = "2")]
    pub is_natural: bool,
    #[prost(message, optional, boxed, tag = "3")]
    pub larg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "4")]
    pub rarg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub using_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub join_using_alias: ::core::option::Option<Alias>,
    #[prost(message, optional, boxed, tag = "7")]
    pub quals: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "8")]
    pub alias: ::core::option::Option<Alias>,
    #[prost(int32, tag = "9")]
    pub rtindex: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FromExpr {
    #[prost(message, repeated, tag = "1")]
    pub fromlist: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "2")]
    pub quals: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnConflictExpr {
    #[prost(enumeration = "OnConflictAction", tag = "1")]
    pub action: i32,
    #[prost(message, repeated, tag = "2")]
    pub arbiter_elems: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub arbiter_where: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "4")]
    pub constraint: u32,
    #[prost(message, repeated, tag = "5")]
    pub on_conflict_set: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "6")]
    pub on_conflict_where: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "7")]
    pub excl_rel_index: i32,
    #[prost(message, repeated, tag = "8")]
    pub excl_rel_tlist: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    #[prost(enumeration = "CmdType", tag = "1")]
    pub command_type: i32,
    #[prost(enumeration = "QuerySource", tag = "2")]
    pub query_source: i32,
    #[prost(bool, tag = "3")]
    pub can_set_tag: bool,
    #[prost(message, optional, boxed, tag = "4")]
    pub utility_stmt: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "5")]
    pub result_relation: i32,
    #[prost(bool, tag = "6")]
    pub has_aggs: bool,
    #[prost(bool, tag = "7")]
    pub has_window_funcs: bool,
    #[prost(bool, tag = "8")]
    pub has_target_srfs: bool,
    #[prost(bool, tag = "9")]
    pub has_sub_links: bool,
    #[prost(bool, tag = "10")]
    pub has_distinct_on: bool,
    #[prost(bool, tag = "11")]
    pub has_recursive: bool,
    #[prost(bool, tag = "12")]
    pub has_modifying_cte: bool,
    #[prost(bool, tag = "13")]
    pub has_for_update: bool,
    #[prost(bool, tag = "14")]
    pub has_row_security: bool,
    #[prost(bool, tag = "15")]
    pub is_return: bool,
    #[prost(message, repeated, tag = "16")]
    pub cte_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "17")]
    pub rtable: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "18")]
    pub rteperminfos: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "19")]
    pub jointree: ::core::option::Option<::prost::alloc::boxed::Box<FromExpr>>,
    #[prost(message, repeated, tag = "20")]
    pub merge_action_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "21")]
    pub merge_target_relation: i32,
    #[prost(message, optional, boxed, tag = "22")]
    pub merge_join_condition: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "23")]
    pub target_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "OverridingKind", tag = "24")]
    pub r#override: i32,
    #[prost(message, optional, boxed, tag = "25")]
    pub on_conflict: ::core::option::Option<::prost::alloc::boxed::Box<OnConflictExpr>>,
    #[prost(message, repeated, tag = "26")]
    pub returning_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "27")]
    pub group_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "28")]
    pub group_distinct: bool,
    #[prost(message, repeated, tag = "29")]
    pub grouping_sets: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "30")]
    pub having_qual: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "31")]
    pub window_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "32")]
    pub distinct_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "33")]
    pub sort_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "34")]
    pub limit_offset: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "35")]
    pub limit_count: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "LimitOption", tag = "36")]
    pub limit_option: i32,
    #[prost(message, repeated, tag = "37")]
    pub row_marks: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "38")]
    pub set_operations: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "39")]
    pub constraint_deps: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "40")]
    pub with_check_options: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "41")]
    pub stmt_location: i32,
    #[prost(int32, tag = "42")]
    pub stmt_len: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeName {
    #[prost(message, repeated, tag = "1")]
    pub names: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "2")]
    pub type_oid: u32,
    #[prost(bool, tag = "3")]
    pub setof: bool,
    #[prost(bool, tag = "4")]
    pub pct_type: bool,
    #[prost(message, repeated, tag = "5")]
    pub typmods: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "6")]
    pub typemod: i32,
    #[prost(message, repeated, tag = "7")]
    pub array_bounds: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnRef {
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "2")]
    pub location: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParamRef {
    #[prost(int32, tag = "1")]
    pub number: i32,
    #[prost(int32, tag = "2")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AExpr {
    #[prost(enumeration = "AExprKind", tag = "1")]
    pub kind: i32,
    #[prost(message, repeated, tag = "2")]
    pub name: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub lexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "4")]
    pub rexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeCast {
    #[prost(message, optional, boxed, tag = "1")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "2")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollateClause {
    #[prost(message, optional, boxed, tag = "1")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub collname: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoleSpec {
    #[prost(enumeration = "RoleSpecType", tag = "1")]
    pub roletype: i32,
    #[prost(string, tag = "2")]
    pub rolename: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FuncCall {
    #[prost(message, repeated, tag = "1")]
    pub funcname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub agg_order: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub agg_filter: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "5")]
    pub over: ::core::option::Option<::prost::alloc::boxed::Box<WindowDef>>,
    #[prost(bool, tag = "6")]
    pub agg_within_group: bool,
    #[prost(bool, tag = "7")]
    pub agg_star: bool,
    #[prost(bool, tag = "8")]
    pub agg_distinct: bool,
    #[prost(bool, tag = "9")]
    pub func_variadic: bool,
    #[prost(enumeration = "CoercionForm", tag = "10")]
    pub funcformat: i32,
    #[prost(int32, tag = "11")]
    pub location: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AStar {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AIndices {
    #[prost(bool, tag = "1")]
    pub is_slice: bool,
    #[prost(message, optional, boxed, tag = "2")]
    pub lidx: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "3")]
    pub uidx: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AIndirection {
    #[prost(message, optional, boxed, tag = "1")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub indirection: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AArrayExpr {
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "2")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResTarget {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub indirection: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub val: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiAssignRef {
    #[prost(message, optional, boxed, tag = "1")]
    pub source: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "2")]
    pub colno: i32,
    #[prost(int32, tag = "3")]
    pub ncolumns: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SortBy {
    #[prost(message, optional, boxed, tag = "1")]
    pub node: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "SortByDir", tag = "2")]
    pub sortby_dir: i32,
    #[prost(enumeration = "SortByNulls", tag = "3")]
    pub sortby_nulls: i32,
    #[prost(message, repeated, tag = "4")]
    pub use_op: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowDef {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub refname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub partition_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub order_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "5")]
    pub frame_options: i32,
    #[prost(message, optional, boxed, tag = "6")]
    pub start_offset: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "7")]
    pub end_offset: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeSubselect {
    #[prost(bool, tag = "1")]
    pub lateral: bool,
    #[prost(message, optional, boxed, tag = "2")]
    pub subquery: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "3")]
    pub alias: ::core::option::Option<Alias>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeFunction {
    #[prost(bool, tag = "1")]
    pub lateral: bool,
    #[prost(bool, tag = "2")]
    pub ordinality: bool,
    #[prost(bool, tag = "3")]
    pub is_rowsfrom: bool,
    #[prost(message, repeated, tag = "4")]
    pub functions: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "5")]
    pub alias: ::core::option::Option<Alias>,
    #[prost(message, repeated, tag = "6")]
    pub coldeflist: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeTableFunc {
    #[prost(bool, tag = "1")]
    pub lateral: bool,
    #[prost(message, optional, boxed, tag = "2")]
    pub docexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "3")]
    pub rowexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "4")]
    pub namespaces: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub columns: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub alias: ::core::option::Option<Alias>,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeTableFuncCol {
    #[prost(string, tag = "1")]
    pub colname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(bool, tag = "3")]
    pub for_ordinality: bool,
    #[prost(bool, tag = "4")]
    pub is_not_null: bool,
    #[prost(message, optional, boxed, tag = "5")]
    pub colexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "6")]
    pub coldefexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "7")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeTableSample {
    #[prost(message, optional, boxed, tag = "1")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub method: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub repeatable: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnDef {
    #[prost(string, tag = "1")]
    pub colname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(string, tag = "3")]
    pub compression: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub inhcount: i32,
    #[prost(bool, tag = "5")]
    pub is_local: bool,
    #[prost(bool, tag = "6")]
    pub is_not_null: bool,
    #[prost(bool, tag = "7")]
    pub is_from_type: bool,
    #[prost(string, tag = "8")]
    pub storage: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub storage_name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "10")]
    pub raw_default: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "11")]
    pub cooked_default: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "12")]
    pub identity: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub identity_sequence: ::core::option::Option<RangeVar>,
    #[prost(string, tag = "14")]
    pub generated: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "15")]
    pub coll_clause: ::core::option::Option<::prost::alloc::boxed::Box<CollateClause>>,
    #[prost(uint32, tag = "16")]
    pub coll_oid: u32,
    #[prost(message, repeated, tag = "17")]
    pub constraints: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "18")]
    pub fdwoptions: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "19")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableLikeClause {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(uint32, tag = "2")]
    pub options: u32,
    #[prost(uint32, tag = "3")]
    pub relation_oid: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexElem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "3")]
    pub indexcolname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub collation: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub opclass: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub opclassopts: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "SortByDir", tag = "7")]
    pub ordering: i32,
    #[prost(enumeration = "SortByNulls", tag = "8")]
    pub nulls_ordering: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefElem {
    #[prost(string, tag = "1")]
    pub defnamespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub defname: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "3")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "DefElemAction", tag = "4")]
    pub defaction: i32,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockingClause {
    #[prost(message, repeated, tag = "1")]
    pub locked_rels: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "LockClauseStrength", tag = "2")]
    pub strength: i32,
    #[prost(enumeration = "LockWaitPolicy", tag = "3")]
    pub wait_policy: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XmlSerialize {
    #[prost(enumeration = "XmlOptionType", tag = "1")]
    pub xmloption: i32,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "3")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(bool, tag = "4")]
    pub indent: bool,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionElem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "3")]
    pub collation: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub opclass: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionSpec {
    #[prost(enumeration = "PartitionStrategy", tag = "1")]
    pub strategy: i32,
    #[prost(message, repeated, tag = "2")]
    pub part_params: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionBoundSpec {
    #[prost(string, tag = "1")]
    pub strategy: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_default: bool,
    #[prost(int32, tag = "3")]
    pub modulus: i32,
    #[prost(int32, tag = "4")]
    pub remainder: i32,
    #[prost(message, repeated, tag = "5")]
    pub listdatums: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub lowerdatums: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "7")]
    pub upperdatums: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionRangeDatum {
    #[prost(enumeration = "PartitionRangeDatumKind", tag = "1")]
    pub kind: i32,
    #[prost(message, optional, boxed, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SinglePartitionSpec {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionCmd {
    #[prost(message, optional, tag = "1")]
    pub name: ::core::option::Option<RangeVar>,
    #[prost(message, optional, tag = "2")]
    pub bound: ::core::option::Option<PartitionBoundSpec>,
    #[prost(bool, tag = "3")]
    pub concurrent: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeTblEntry {
    #[prost(message, optional, tag = "1")]
    pub alias: ::core::option::Option<Alias>,
    #[prost(message, optional, tag = "2")]
    pub eref: ::core::option::Option<Alias>,
    #[prost(enumeration = "RteKind", tag = "3")]
    pub rtekind: i32,
    #[prost(uint32, tag = "4")]
    pub relid: u32,
    #[prost(bool, tag = "5")]
    pub inh: bool,
    #[prost(string, tag = "6")]
    pub relkind: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub rellockmode: i32,
    #[prost(uint32, tag = "8")]
    pub perminfoindex: u32,
    #[prost(message, optional, boxed, tag = "9")]
    pub tablesample: ::core::option::Option<
        ::prost::alloc::boxed::Box<TableSampleClause>,
    >,
    #[prost(message, optional, boxed, tag = "10")]
    pub subquery: ::core::option::Option<::prost::alloc::boxed::Box<Query>>,
    #[prost(bool, tag = "11")]
    pub security_barrier: bool,
    #[prost(enumeration = "JoinType", tag = "12")]
    pub jointype: i32,
    #[prost(int32, tag = "13")]
    pub joinmergedcols: i32,
    #[prost(message, repeated, tag = "14")]
    pub joinaliasvars: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "15")]
    pub joinleftcols: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "16")]
    pub joinrightcols: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "17")]
    pub join_using_alias: ::core::option::Option<Alias>,
    #[prost(message, repeated, tag = "18")]
    pub functions: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "19")]
    pub funcordinality: bool,
    #[prost(message, optional, boxed, tag = "20")]
    pub tablefunc: ::core::option::Option<::prost::alloc::boxed::Box<TableFunc>>,
    #[prost(message, repeated, tag = "21")]
    pub values_lists: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "22")]
    pub ctename: ::prost::alloc::string::String,
    #[prost(uint32, tag = "23")]
    pub ctelevelsup: u32,
    #[prost(bool, tag = "24")]
    pub self_reference: bool,
    #[prost(message, repeated, tag = "25")]
    pub coltypes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "26")]
    pub coltypmods: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "27")]
    pub colcollations: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "28")]
    pub enrname: ::prost::alloc::string::String,
    #[prost(double, tag = "29")]
    pub enrtuples: f64,
    #[prost(bool, tag = "30")]
    pub lateral: bool,
    #[prost(bool, tag = "31")]
    pub in_from_cl: bool,
    #[prost(message, repeated, tag = "32")]
    pub security_quals: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RtePermissionInfo {
    #[prost(uint32, tag = "1")]
    pub relid: u32,
    #[prost(bool, tag = "2")]
    pub inh: bool,
    #[prost(uint64, tag = "3")]
    pub required_perms: u64,
    #[prost(uint32, tag = "4")]
    pub check_as_user: u32,
    #[prost(uint64, repeated, tag = "5")]
    pub selected_cols: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, tag = "6")]
    pub inserted_cols: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, tag = "7")]
    pub updated_cols: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeTblFunction {
    #[prost(message, optional, boxed, tag = "1")]
    pub funcexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "2")]
    pub funccolcount: i32,
    #[prost(message, repeated, tag = "3")]
    pub funccolnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub funccoltypes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub funccoltypmods: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub funccolcollations: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint64, repeated, tag = "7")]
    pub funcparams: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableSampleClause {
    #[prost(uint32, tag = "1")]
    pub tsmhandler: u32,
    #[prost(message, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub repeatable: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithCheckOption {
    #[prost(enumeration = "WcoKind", tag = "1")]
    pub kind: i32,
    #[prost(string, tag = "2")]
    pub relname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub polname: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "4")]
    pub qual: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(bool, tag = "5")]
    pub cascaded: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SortGroupClause {
    #[prost(uint32, tag = "1")]
    pub tle_sort_group_ref: u32,
    #[prost(uint32, tag = "2")]
    pub eqop: u32,
    #[prost(uint32, tag = "3")]
    pub sortop: u32,
    #[prost(bool, tag = "4")]
    pub nulls_first: bool,
    #[prost(bool, tag = "5")]
    pub hashable: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupingSet {
    #[prost(enumeration = "GroupingSetKind", tag = "1")]
    pub kind: i32,
    #[prost(message, repeated, tag = "2")]
    pub content: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowClause {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub refname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub partition_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub order_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "5")]
    pub frame_options: i32,
    #[prost(message, optional, boxed, tag = "6")]
    pub start_offset: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "7")]
    pub end_offset: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(uint32, tag = "8")]
    pub start_in_range_func: u32,
    #[prost(uint32, tag = "9")]
    pub end_in_range_func: u32,
    #[prost(uint32, tag = "10")]
    pub in_range_coll: u32,
    #[prost(bool, tag = "11")]
    pub in_range_asc: bool,
    #[prost(bool, tag = "12")]
    pub in_range_nulls_first: bool,
    #[prost(uint32, tag = "13")]
    pub winref: u32,
    #[prost(bool, tag = "14")]
    pub copied_order: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RowMarkClause {
    #[prost(uint32, tag = "1")]
    pub rti: u32,
    #[prost(enumeration = "LockClauseStrength", tag = "2")]
    pub strength: i32,
    #[prost(enumeration = "LockWaitPolicy", tag = "3")]
    pub wait_policy: i32,
    #[prost(bool, tag = "4")]
    pub pushed_down: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithClause {
    #[prost(message, repeated, tag = "1")]
    pub ctes: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "2")]
    pub recursive: bool,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InferClause {
    #[prost(message, repeated, tag = "1")]
    pub index_elems: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "2")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "3")]
    pub conname: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnConflictClause {
    #[prost(enumeration = "OnConflictAction", tag = "1")]
    pub action: i32,
    #[prost(message, optional, boxed, tag = "2")]
    pub infer: ::core::option::Option<::prost::alloc::boxed::Box<InferClause>>,
    #[prost(message, repeated, tag = "3")]
    pub target_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CteSearchClause {
    #[prost(message, repeated, tag = "1")]
    pub search_col_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "2")]
    pub search_breadth_first: bool,
    #[prost(string, tag = "3")]
    pub search_seq_column: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CteCycleClause {
    #[prost(message, repeated, tag = "1")]
    pub cycle_col_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "2")]
    pub cycle_mark_column: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "3")]
    pub cycle_mark_value: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "4")]
    pub cycle_mark_default: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "5")]
    pub cycle_path_column: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub location: i32,
    #[prost(uint32, tag = "7")]
    pub cycle_mark_type: u32,
    #[prost(int32, tag = "8")]
    pub cycle_mark_typmod: i32,
    #[prost(uint32, tag = "9")]
    pub cycle_mark_collation: u32,
    #[prost(uint32, tag = "10")]
    pub cycle_mark_neop: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonTableExpr {
    #[prost(string, tag = "1")]
    pub ctename: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub aliascolnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "CteMaterialize", tag = "3")]
    pub ctematerialized: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub ctequery: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "5")]
    pub search_clause: ::core::option::Option<CteSearchClause>,
    #[prost(message, optional, boxed, tag = "6")]
    pub cycle_clause: ::core::option::Option<::prost::alloc::boxed::Box<CteCycleClause>>,
    #[prost(int32, tag = "7")]
    pub location: i32,
    #[prost(bool, tag = "8")]
    pub cterecursive: bool,
    #[prost(int32, tag = "9")]
    pub cterefcount: i32,
    #[prost(message, repeated, tag = "10")]
    pub ctecolnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "11")]
    pub ctecoltypes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "12")]
    pub ctecoltypmods: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "13")]
    pub ctecolcollations: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeWhenClause {
    #[prost(enumeration = "MergeMatchKind", tag = "1")]
    pub match_kind: i32,
    #[prost(enumeration = "CmdType", tag = "2")]
    pub command_type: i32,
    #[prost(enumeration = "OverridingKind", tag = "3")]
    pub r#override: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub condition: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub target_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub values: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerTransition {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_new: bool,
    #[prost(bool, tag = "3")]
    pub is_table: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonOutput {
    #[prost(message, optional, tag = "1")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(message, optional, tag = "2")]
    pub returning: ::core::option::Option<JsonReturning>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonArgument {
    #[prost(message, optional, boxed, tag = "1")]
    pub val: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonFuncExpr {
    #[prost(enumeration = "JsonExprOp", tag = "1")]
    pub op: i32,
    #[prost(string, tag = "2")]
    pub column_name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "3")]
    pub context_item: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
    #[prost(message, optional, boxed, tag = "4")]
    pub pathspec: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub passing: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(message, optional, boxed, tag = "7")]
    pub on_empty: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(message, optional, boxed, tag = "8")]
    pub on_error: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(enumeration = "JsonWrapper", tag = "9")]
    pub wrapper: i32,
    #[prost(enumeration = "JsonQuotes", tag = "10")]
    pub quotes: i32,
    #[prost(int32, tag = "11")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonTablePathSpec {
    #[prost(message, optional, boxed, tag = "1")]
    pub string: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub name_location: i32,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonTable {
    #[prost(message, optional, boxed, tag = "1")]
    pub context_item: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub pathspec: ::core::option::Option<::prost::alloc::boxed::Box<JsonTablePathSpec>>,
    #[prost(message, repeated, tag = "3")]
    pub passing: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub columns: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "5")]
    pub on_error: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(message, optional, tag = "6")]
    pub alias: ::core::option::Option<Alias>,
    #[prost(bool, tag = "7")]
    pub lateral: bool,
    #[prost(int32, tag = "8")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonTableColumn {
    #[prost(enumeration = "JsonTableColumnType", tag = "1")]
    pub coltype: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(message, optional, boxed, tag = "4")]
    pub pathspec: ::core::option::Option<::prost::alloc::boxed::Box<JsonTablePathSpec>>,
    #[prost(message, optional, tag = "5")]
    pub format: ::core::option::Option<JsonFormat>,
    #[prost(enumeration = "JsonWrapper", tag = "6")]
    pub wrapper: i32,
    #[prost(enumeration = "JsonQuotes", tag = "7")]
    pub quotes: i32,
    #[prost(message, repeated, tag = "8")]
    pub columns: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "9")]
    pub on_empty: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(message, optional, boxed, tag = "10")]
    pub on_error: ::core::option::Option<::prost::alloc::boxed::Box<JsonBehavior>>,
    #[prost(int32, tag = "11")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonKeyValue {
    #[prost(message, optional, boxed, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonParseExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(bool, tag = "3")]
    pub unique_keys: bool,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonScalarExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonSerializeExpr {
    #[prost(message, optional, boxed, tag = "1")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonObjectConstructor {
    #[prost(message, repeated, tag = "1")]
    pub exprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(bool, tag = "3")]
    pub absent_on_null: bool,
    #[prost(bool, tag = "4")]
    pub unique: bool,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonArrayConstructor {
    #[prost(message, repeated, tag = "1")]
    pub exprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(bool, tag = "3")]
    pub absent_on_null: bool,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonArrayQueryConstructor {
    #[prost(message, optional, boxed, tag = "1")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(message, optional, tag = "3")]
    pub format: ::core::option::Option<JsonFormat>,
    #[prost(bool, tag = "4")]
    pub absent_on_null: bool,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonAggConstructor {
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<JsonOutput>,
    #[prost(message, optional, boxed, tag = "2")]
    pub agg_filter: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "3")]
    pub agg_order: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub over: ::core::option::Option<::prost::alloc::boxed::Box<WindowDef>>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonObjectAgg {
    #[prost(message, optional, boxed, tag = "1")]
    pub constructor: ::core::option::Option<
        ::prost::alloc::boxed::Box<JsonAggConstructor>,
    >,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<JsonKeyValue>>,
    #[prost(bool, tag = "3")]
    pub absent_on_null: bool,
    #[prost(bool, tag = "4")]
    pub unique: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonArrayAgg {
    #[prost(message, optional, boxed, tag = "1")]
    pub constructor: ::core::option::Option<
        ::prost::alloc::boxed::Box<JsonAggConstructor>,
    >,
    #[prost(message, optional, boxed, tag = "2")]
    pub arg: ::core::option::Option<::prost::alloc::boxed::Box<JsonValueExpr>>,
    #[prost(bool, tag = "3")]
    pub absent_on_null: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawStmt {
    #[prost(message, optional, boxed, tag = "1")]
    pub stmt: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(int32, tag = "2")]
    pub stmt_location: i32,
    #[prost(int32, tag = "3")]
    pub stmt_len: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub cols: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub select_stmt: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "4")]
    pub on_conflict_clause: ::core::option::Option<
        ::prost::alloc::boxed::Box<OnConflictClause>,
    >,
    #[prost(message, repeated, tag = "5")]
    pub returning_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub with_clause: ::core::option::Option<WithClause>,
    #[prost(enumeration = "OverridingKind", tag = "7")]
    pub r#override: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub using_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "4")]
    pub returning_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "5")]
    pub with_clause: ::core::option::Option<WithClause>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub target_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "4")]
    pub from_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub returning_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub with_clause: ::core::option::Option<WithClause>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "2")]
    pub source_relation: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "3")]
    pub join_condition: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "4")]
    pub merge_when_clauses: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub returning_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub with_clause: ::core::option::Option<WithClause>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectStmt {
    #[prost(message, repeated, tag = "1")]
    pub distinct_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "2")]
    pub into_clause: ::core::option::Option<::prost::alloc::boxed::Box<IntoClause>>,
    #[prost(message, repeated, tag = "3")]
    pub target_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub from_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "5")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "6")]
    pub group_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "7")]
    pub group_distinct: bool,
    #[prost(message, optional, boxed, tag = "8")]
    pub having_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "9")]
    pub window_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "10")]
    pub values_lists: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "11")]
    pub sort_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "12")]
    pub limit_offset: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "13")]
    pub limit_count: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "LimitOption", tag = "14")]
    pub limit_option: i32,
    #[prost(message, repeated, tag = "15")]
    pub locking_clause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "16")]
    pub with_clause: ::core::option::Option<WithClause>,
    #[prost(enumeration = "SetOperation", tag = "17")]
    pub op: i32,
    #[prost(bool, tag = "18")]
    pub all: bool,
    #[prost(message, optional, boxed, tag = "19")]
    pub larg: ::core::option::Option<::prost::alloc::boxed::Box<SelectStmt>>,
    #[prost(message, optional, boxed, tag = "20")]
    pub rarg: ::core::option::Option<::prost::alloc::boxed::Box<SelectStmt>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetOperationStmt {
    #[prost(enumeration = "SetOperation", tag = "1")]
    pub op: i32,
    #[prost(bool, tag = "2")]
    pub all: bool,
    #[prost(message, optional, boxed, tag = "3")]
    pub larg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "4")]
    pub rarg: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "5")]
    pub col_types: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub col_typmods: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "7")]
    pub col_collations: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "8")]
    pub group_clauses: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReturnStmt {
    #[prost(message, optional, boxed, tag = "1")]
    pub returnval: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlAssignStmt {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub indirection: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "3")]
    pub nnames: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub val: ::core::option::Option<::prost::alloc::boxed::Box<SelectStmt>>,
    #[prost(int32, tag = "5")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSchemaStmt {
    #[prost(string, tag = "1")]
    pub schemaname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub authrole: ::core::option::Option<RoleSpec>,
    #[prost(message, repeated, tag = "3")]
    pub schema_elts: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub if_not_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTableStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub cmds: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "ObjectType", tag = "3")]
    pub objtype: i32,
    #[prost(bool, tag = "4")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicaIdentityStmt {
    #[prost(string, tag = "1")]
    pub identity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTableCmd {
    #[prost(enumeration = "AlterTableType", tag = "1")]
    pub subtype: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub num: i32,
    #[prost(message, optional, tag = "4")]
    pub newowner: ::core::option::Option<RoleSpec>,
    #[prost(message, optional, boxed, tag = "5")]
    pub def: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "DropBehavior", tag = "6")]
    pub behavior: i32,
    #[prost(bool, tag = "7")]
    pub missing_ok: bool,
    #[prost(bool, tag = "8")]
    pub recurse: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterCollationStmt {
    #[prost(message, repeated, tag = "1")]
    pub collname: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterDomainStmt {
    #[prost(string, tag = "1")]
    pub subtype: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub type_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "4")]
    pub def: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "DropBehavior", tag = "5")]
    pub behavior: i32,
    #[prost(bool, tag = "6")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantStmt {
    #[prost(bool, tag = "1")]
    pub is_grant: bool,
    #[prost(enumeration = "GrantTargetType", tag = "2")]
    pub targtype: i32,
    #[prost(enumeration = "ObjectType", tag = "3")]
    pub objtype: i32,
    #[prost(message, repeated, tag = "4")]
    pub objects: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub privileges: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub grantees: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "7")]
    pub grant_option: bool,
    #[prost(message, optional, tag = "8")]
    pub grantor: ::core::option::Option<RoleSpec>,
    #[prost(enumeration = "DropBehavior", tag = "9")]
    pub behavior: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectWithArgs {
    #[prost(message, repeated, tag = "1")]
    pub objname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub objargs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub objfuncargs: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub args_unspecified: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPriv {
    #[prost(string, tag = "1")]
    pub priv_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub cols: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantRoleStmt {
    #[prost(message, repeated, tag = "1")]
    pub granted_roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub grantee_roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "3")]
    pub is_grant: bool,
    #[prost(message, repeated, tag = "4")]
    pub opt: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "5")]
    pub grantor: ::core::option::Option<RoleSpec>,
    #[prost(enumeration = "DropBehavior", tag = "6")]
    pub behavior: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterDefaultPrivilegesStmt {
    #[prost(message, repeated, tag = "1")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "2")]
    pub action: ::core::option::Option<GrantStmt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "2")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "3")]
    pub attlist: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub is_from: bool,
    #[prost(bool, tag = "5")]
    pub is_program: bool,
    #[prost(string, tag = "6")]
    pub filename: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "8")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariableSetStmt {
    #[prost(enumeration = "VariableSetKind", tag = "1")]
    pub kind: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub is_local: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariableShowStmt {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub table_elts: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub inh_relations: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "4")]
    pub partbound: ::core::option::Option<PartitionBoundSpec>,
    #[prost(message, optional, tag = "5")]
    pub partspec: ::core::option::Option<PartitionSpec>,
    #[prost(message, optional, tag = "6")]
    pub of_typename: ::core::option::Option<TypeName>,
    #[prost(message, repeated, tag = "7")]
    pub constraints: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "8")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "OnCommitAction", tag = "9")]
    pub oncommit: i32,
    #[prost(string, tag = "10")]
    pub tablespacename: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub access_method: ::prost::alloc::string::String,
    #[prost(bool, tag = "12")]
    pub if_not_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Constraint {
    #[prost(enumeration = "ConstrType", tag = "1")]
    pub contype: i32,
    #[prost(string, tag = "2")]
    pub conname: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub deferrable: bool,
    #[prost(bool, tag = "4")]
    pub initdeferred: bool,
    #[prost(bool, tag = "5")]
    pub skip_validation: bool,
    #[prost(bool, tag = "6")]
    pub initially_valid: bool,
    #[prost(bool, tag = "7")]
    pub is_no_inherit: bool,
    #[prost(message, optional, boxed, tag = "8")]
    pub raw_expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "9")]
    pub cooked_expr: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub generated_when: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub inhcount: i32,
    #[prost(bool, tag = "12")]
    pub nulls_not_distinct: bool,
    #[prost(message, repeated, tag = "13")]
    pub keys: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "14")]
    pub including: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "15")]
    pub exclusions: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "16")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "17")]
    pub indexname: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub indexspace: ::prost::alloc::string::String,
    #[prost(bool, tag = "19")]
    pub reset_default_tblspc: bool,
    #[prost(string, tag = "20")]
    pub access_method: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "21")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "22")]
    pub pktable: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "23")]
    pub fk_attrs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "24")]
    pub pk_attrs: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "25")]
    pub fk_matchtype: ::prost::alloc::string::String,
    #[prost(string, tag = "26")]
    pub fk_upd_action: ::prost::alloc::string::String,
    #[prost(string, tag = "27")]
    pub fk_del_action: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "28")]
    pub fk_del_set_cols: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "29")]
    pub old_conpfeqop: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "30")]
    pub old_pktable_oid: u32,
    #[prost(int32, tag = "31")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTableSpaceStmt {
    #[prost(string, tag = "1")]
    pub tablespacename: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<RoleSpec>,
    #[prost(string, tag = "3")]
    pub location: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropTableSpaceStmt {
    #[prost(string, tag = "1")]
    pub tablespacename: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTableSpaceOptionsStmt {
    #[prost(string, tag = "1")]
    pub tablespacename: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "3")]
    pub is_reset: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTableMoveAllStmt {
    #[prost(string, tag = "1")]
    pub orig_tablespacename: ::prost::alloc::string::String,
    #[prost(enumeration = "ObjectType", tag = "2")]
    pub objtype: i32,
    #[prost(message, repeated, tag = "3")]
    pub roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "4")]
    pub new_tablespacename: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub nowait: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExtensionStmt {
    #[prost(string, tag = "1")]
    pub extname: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub if_not_exists: bool,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterExtensionStmt {
    #[prost(string, tag = "1")]
    pub extname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterExtensionContentsStmt {
    #[prost(string, tag = "1")]
    pub extname: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub action: i32,
    #[prost(enumeration = "ObjectType", tag = "3")]
    pub objtype: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFdwStmt {
    #[prost(string, tag = "1")]
    pub fdwname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub func_options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterFdwStmt {
    #[prost(string, tag = "1")]
    pub fdwname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub func_options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateForeignServerStmt {
    #[prost(string, tag = "1")]
    pub servername: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub servertype: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub fdwname: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub if_not_exists: bool,
    #[prost(message, repeated, tag = "6")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterForeignServerStmt {
    #[prost(string, tag = "1")]
    pub servername: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub has_version: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateForeignTableStmt {
    #[prost(message, optional, tag = "1")]
    pub base_stmt: ::core::option::Option<CreateStmt>,
    #[prost(string, tag = "2")]
    pub servername: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserMappingStmt {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<RoleSpec>,
    #[prost(string, tag = "2")]
    pub servername: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub if_not_exists: bool,
    #[prost(message, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterUserMappingStmt {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<RoleSpec>,
    #[prost(string, tag = "2")]
    pub servername: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropUserMappingStmt {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<RoleSpec>,
    #[prost(string, tag = "2")]
    pub servername: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportForeignSchemaStmt {
    #[prost(string, tag = "1")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub remote_schema: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub local_schema: ::prost::alloc::string::String,
    #[prost(enumeration = "ImportForeignSchemaType", tag = "4")]
    pub list_type: i32,
    #[prost(message, repeated, tag = "5")]
    pub table_list: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePolicyStmt {
    #[prost(string, tag = "1")]
    pub policy_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub table: ::core::option::Option<RangeVar>,
    #[prost(string, tag = "3")]
    pub cmd_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub permissive: bool,
    #[prost(message, repeated, tag = "5")]
    pub roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "6")]
    pub qual: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "7")]
    pub with_check: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterPolicyStmt {
    #[prost(string, tag = "1")]
    pub policy_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub table: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "3")]
    pub roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "4")]
    pub qual: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "5")]
    pub with_check: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAmStmt {
    #[prost(string, tag = "1")]
    pub amname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub handler_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "3")]
    pub amtype: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTrigStmt {
    #[prost(bool, tag = "1")]
    pub replace: bool,
    #[prost(bool, tag = "2")]
    pub isconstraint: bool,
    #[prost(string, tag = "3")]
    pub trigname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "5")]
    pub funcname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "7")]
    pub row: bool,
    #[prost(int32, tag = "8")]
    pub timing: i32,
    #[prost(int32, tag = "9")]
    pub events: i32,
    #[prost(message, repeated, tag = "10")]
    pub columns: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "11")]
    pub when_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "12")]
    pub transition_rels: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "13")]
    pub deferrable: bool,
    #[prost(bool, tag = "14")]
    pub initdeferred: bool,
    #[prost(message, optional, tag = "15")]
    pub constrrel: ::core::option::Option<RangeVar>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventTrigStmt {
    #[prost(string, tag = "1")]
    pub trigname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub eventname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub whenclause: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub funcname: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterEventTrigStmt {
    #[prost(string, tag = "1")]
    pub trigname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tgenabled: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePLangStmt {
    #[prost(bool, tag = "1")]
    pub replace: bool,
    #[prost(string, tag = "2")]
    pub plname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub plhandler: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub plinline: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub plvalidator: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "6")]
    pub pltrusted: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRoleStmt {
    #[prost(enumeration = "RoleStmtType", tag = "1")]
    pub stmt_type: i32,
    #[prost(string, tag = "2")]
    pub role: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterRoleStmt {
    #[prost(message, optional, tag = "1")]
    pub role: ::core::option::Option<RoleSpec>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "3")]
    pub action: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterRoleSetStmt {
    #[prost(message, optional, tag = "1")]
    pub role: ::core::option::Option<RoleSpec>,
    #[prost(string, tag = "2")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub setstmt: ::core::option::Option<VariableSetStmt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropRoleStmt {
    #[prost(message, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "2")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSeqStmt {
    #[prost(message, optional, tag = "1")]
    pub sequence: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(uint32, tag = "3")]
    pub owner_id: u32,
    #[prost(bool, tag = "4")]
    pub for_identity: bool,
    #[prost(bool, tag = "5")]
    pub if_not_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterSeqStmt {
    #[prost(message, optional, tag = "1")]
    pub sequence: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "3")]
    pub for_identity: bool,
    #[prost(bool, tag = "4")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefineStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub kind: i32,
    #[prost(bool, tag = "2")]
    pub oldstyle: bool,
    #[prost(message, repeated, tag = "3")]
    pub defnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub definition: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "6")]
    pub if_not_exists: bool,
    #[prost(bool, tag = "7")]
    pub replace: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDomainStmt {
    #[prost(message, repeated, tag = "1")]
    pub domainname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "2")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(message, optional, boxed, tag = "3")]
    pub coll_clause: ::core::option::Option<::prost::alloc::boxed::Box<CollateClause>>,
    #[prost(message, repeated, tag = "4")]
    pub constraints: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOpClassStmt {
    #[prost(message, repeated, tag = "1")]
    pub opclassname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub opfamilyname: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "3")]
    pub amname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub datatype: ::core::option::Option<TypeName>,
    #[prost(message, repeated, tag = "5")]
    pub items: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "6")]
    pub is_default: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOpClassItem {
    #[prost(int32, tag = "1")]
    pub itemtype: i32,
    #[prost(message, optional, tag = "2")]
    pub name: ::core::option::Option<ObjectWithArgs>,
    #[prost(int32, tag = "3")]
    pub number: i32,
    #[prost(message, repeated, tag = "4")]
    pub order_family: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub class_args: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "6")]
    pub storedtype: ::core::option::Option<TypeName>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOpFamilyStmt {
    #[prost(message, repeated, tag = "1")]
    pub opfamilyname: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "2")]
    pub amname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterOpFamilyStmt {
    #[prost(message, repeated, tag = "1")]
    pub opfamilyname: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "2")]
    pub amname: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_drop: bool,
    #[prost(message, repeated, tag = "4")]
    pub items: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropStmt {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "ObjectType", tag = "2")]
    pub remove_type: i32,
    #[prost(enumeration = "DropBehavior", tag = "3")]
    pub behavior: i32,
    #[prost(bool, tag = "4")]
    pub missing_ok: bool,
    #[prost(bool, tag = "5")]
    pub concurrent: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncateStmt {
    #[prost(message, repeated, tag = "1")]
    pub relations: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "2")]
    pub restart_seqs: bool,
    #[prost(enumeration = "DropBehavior", tag = "3")]
    pub behavior: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommentStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub objtype: i32,
    #[prost(message, optional, boxed, tag = "2")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "3")]
    pub comment: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecLabelStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub objtype: i32,
    #[prost(message, optional, boxed, tag = "2")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "3")]
    pub provider: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub label: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclareCursorStmt {
    #[prost(string, tag = "1")]
    pub portalname: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub options: i32,
    #[prost(message, optional, boxed, tag = "3")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClosePortalStmt {
    #[prost(string, tag = "1")]
    pub portalname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchStmt {
    #[prost(enumeration = "FetchDirection", tag = "1")]
    pub direction: i32,
    #[prost(int64, tag = "2")]
    pub how_many: i64,
    #[prost(string, tag = "3")]
    pub portalname: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub ismove: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexStmt {
    #[prost(string, tag = "1")]
    pub idxname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(string, tag = "3")]
    pub access_method: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub table_space: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub index_params: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "6")]
    pub index_including_params: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "7")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "8")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "9")]
    pub exclude_op_names: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "10")]
    pub idxcomment: ::prost::alloc::string::String,
    #[prost(uint32, tag = "11")]
    pub index_oid: u32,
    #[prost(uint32, tag = "12")]
    pub old_number: u32,
    #[prost(uint32, tag = "13")]
    pub old_create_subid: u32,
    #[prost(uint32, tag = "14")]
    pub old_first_relfilelocator_subid: u32,
    #[prost(bool, tag = "15")]
    pub unique: bool,
    #[prost(bool, tag = "16")]
    pub nulls_not_distinct: bool,
    #[prost(bool, tag = "17")]
    pub primary: bool,
    #[prost(bool, tag = "18")]
    pub isconstraint: bool,
    #[prost(bool, tag = "19")]
    pub deferrable: bool,
    #[prost(bool, tag = "20")]
    pub initdeferred: bool,
    #[prost(bool, tag = "21")]
    pub transformed: bool,
    #[prost(bool, tag = "22")]
    pub concurrent: bool,
    #[prost(bool, tag = "23")]
    pub if_not_exists: bool,
    #[prost(bool, tag = "24")]
    pub reset_default_tblspc: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStatsStmt {
    #[prost(message, repeated, tag = "1")]
    pub defnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub stat_types: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub exprs: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub relations: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "5")]
    pub stxcomment: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub transformed: bool,
    #[prost(bool, tag = "7")]
    pub if_not_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsElem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub expr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterStatsStmt {
    #[prost(message, repeated, tag = "1")]
    pub defnames: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "2")]
    pub stxstattarget: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(bool, tag = "3")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFunctionStmt {
    #[prost(bool, tag = "1")]
    pub is_procedure: bool,
    #[prost(bool, tag = "2")]
    pub replace: bool,
    #[prost(message, repeated, tag = "3")]
    pub funcname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub parameters: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "5")]
    pub return_type: ::core::option::Option<TypeName>,
    #[prost(message, repeated, tag = "6")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "7")]
    pub sql_body: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionParameter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub arg_type: ::core::option::Option<TypeName>,
    #[prost(enumeration = "FunctionParameterMode", tag = "3")]
    pub mode: i32,
    #[prost(message, optional, boxed, tag = "4")]
    pub defexpr: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterFunctionStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub objtype: i32,
    #[prost(message, optional, tag = "2")]
    pub func: ::core::option::Option<ObjectWithArgs>,
    #[prost(message, repeated, tag = "3")]
    pub actions: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoStmt {
    #[prost(message, repeated, tag = "1")]
    pub args: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineCodeBlock {
    #[prost(string, tag = "1")]
    pub source_text: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub lang_oid: u32,
    #[prost(bool, tag = "3")]
    pub lang_is_trusted: bool,
    #[prost(bool, tag = "4")]
    pub atomic: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallStmt {
    #[prost(message, optional, boxed, tag = "1")]
    pub funccall: ::core::option::Option<::prost::alloc::boxed::Box<FuncCall>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub funcexpr: ::core::option::Option<::prost::alloc::boxed::Box<FuncExpr>>,
    #[prost(message, repeated, tag = "3")]
    pub outargs: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallContext {
    #[prost(bool, tag = "1")]
    pub atomic: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenameStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub rename_type: i32,
    #[prost(enumeration = "ObjectType", tag = "2")]
    pub relation_type: i32,
    #[prost(message, optional, tag = "3")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "4")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "5")]
    pub subname: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub newname: ::prost::alloc::string::String,
    #[prost(enumeration = "DropBehavior", tag = "7")]
    pub behavior: i32,
    #[prost(bool, tag = "8")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterObjectDependsStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub object_type: i32,
    #[prost(message, optional, tag = "2")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "3")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "4")]
    pub extname: ::core::option::Option<String>,
    #[prost(bool, tag = "5")]
    pub remove: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterObjectSchemaStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub object_type: i32,
    #[prost(message, optional, tag = "2")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "3")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(string, tag = "4")]
    pub newschema: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterOwnerStmt {
    #[prost(enumeration = "ObjectType", tag = "1")]
    pub object_type: i32,
    #[prost(message, optional, tag = "2")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "3")]
    pub object: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, tag = "4")]
    pub newowner: ::core::option::Option<RoleSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterOperatorStmt {
    #[prost(message, optional, tag = "1")]
    pub opername: ::core::option::Option<ObjectWithArgs>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTypeStmt {
    #[prost(message, repeated, tag = "1")]
    pub type_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(string, tag = "2")]
    pub rulename: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "3")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(enumeration = "CmdType", tag = "4")]
    pub event: i32,
    #[prost(bool, tag = "5")]
    pub instead: bool,
    #[prost(message, repeated, tag = "6")]
    pub actions: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "7")]
    pub replace: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyStmt {
    #[prost(string, tag = "1")]
    pub conditionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub payload: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenStmt {
    #[prost(string, tag = "1")]
    pub conditionname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlistenStmt {
    #[prost(string, tag = "1")]
    pub conditionname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionStmt {
    #[prost(enumeration = "TransactionStmtKind", tag = "1")]
    pub kind: i32,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "3")]
    pub savepoint_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gid: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub chain: bool,
    #[prost(int32, tag = "6")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeTypeStmt {
    #[prost(message, optional, tag = "1")]
    pub typevar: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub coldeflist: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEnumStmt {
    #[prost(message, repeated, tag = "1")]
    pub type_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub vals: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRangeStmt {
    #[prost(message, repeated, tag = "1")]
    pub type_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterEnumStmt {
    #[prost(message, repeated, tag = "1")]
    pub type_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "2")]
    pub old_val: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub new_val: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub new_val_neighbor: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub new_val_is_after: bool,
    #[prost(bool, tag = "6")]
    pub skip_if_new_val_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewStmt {
    #[prost(message, optional, tag = "1")]
    pub view: ::core::option::Option<RangeVar>,
    #[prost(message, repeated, tag = "2")]
    pub aliases: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(bool, tag = "4")]
    pub replace: bool,
    #[prost(message, repeated, tag = "5")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "ViewCheckOption", tag = "6")]
    pub with_check_option: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadStmt {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatedbStmt {
    #[prost(string, tag = "1")]
    pub dbname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterDatabaseStmt {
    #[prost(string, tag = "1")]
    pub dbname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterDatabaseRefreshCollStmt {
    #[prost(string, tag = "1")]
    pub dbname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterDatabaseSetStmt {
    #[prost(string, tag = "1")]
    pub dbname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub setstmt: ::core::option::Option<VariableSetStmt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropdbStmt {
    #[prost(string, tag = "1")]
    pub dbname: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub missing_ok: bool,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterSystemStmt {
    #[prost(message, optional, tag = "1")]
    pub setstmt: ::core::option::Option<VariableSetStmt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterStmt {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(string, tag = "2")]
    pub indexname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub params: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VacuumStmt {
    #[prost(message, repeated, tag = "1")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub rels: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "3")]
    pub is_vacuumcmd: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VacuumRelation {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(uint32, tag = "2")]
    pub oid: u32,
    #[prost(message, repeated, tag = "3")]
    pub va_cols: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplainStmt {
    #[prost(message, optional, boxed, tag = "1")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTableAsStmt {
    #[prost(message, optional, boxed, tag = "1")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub into: ::core::option::Option<::prost::alloc::boxed::Box<IntoClause>>,
    #[prost(enumeration = "ObjectType", tag = "3")]
    pub objtype: i32,
    #[prost(bool, tag = "4")]
    pub is_select_into: bool,
    #[prost(bool, tag = "5")]
    pub if_not_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshMatViewStmt {
    #[prost(bool, tag = "1")]
    pub concurrent: bool,
    #[prost(bool, tag = "2")]
    pub skip_data: bool,
    #[prost(message, optional, tag = "3")]
    pub relation: ::core::option::Option<RangeVar>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckPointStmt {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiscardStmt {
    #[prost(enumeration = "DiscardMode", tag = "1")]
    pub target: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockStmt {
    #[prost(message, repeated, tag = "1")]
    pub relations: ::prost::alloc::vec::Vec<Node>,
    #[prost(int32, tag = "2")]
    pub mode: i32,
    #[prost(bool, tag = "3")]
    pub nowait: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstraintsSetStmt {
    #[prost(message, repeated, tag = "1")]
    pub constraints: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "2")]
    pub deferred: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReindexStmt {
    #[prost(enumeration = "ReindexObjectType", tag = "1")]
    pub kind: i32,
    #[prost(message, optional, tag = "2")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub params: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversionStmt {
    #[prost(message, repeated, tag = "1")]
    pub conversion_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "2")]
    pub for_encoding_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub to_encoding_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub func_name: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "5")]
    pub def: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCastStmt {
    #[prost(message, optional, tag = "1")]
    pub sourcetype: ::core::option::Option<TypeName>,
    #[prost(message, optional, tag = "2")]
    pub targettype: ::core::option::Option<TypeName>,
    #[prost(message, optional, tag = "3")]
    pub func: ::core::option::Option<ObjectWithArgs>,
    #[prost(enumeration = "CoercionContext", tag = "4")]
    pub context: i32,
    #[prost(bool, tag = "5")]
    pub inout: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTransformStmt {
    #[prost(bool, tag = "1")]
    pub replace: bool,
    #[prost(message, optional, tag = "2")]
    pub type_name: ::core::option::Option<TypeName>,
    #[prost(string, tag = "3")]
    pub lang: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub fromsql: ::core::option::Option<ObjectWithArgs>,
    #[prost(message, optional, tag = "5")]
    pub tosql: ::core::option::Option<ObjectWithArgs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareStmt {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub argtypes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, boxed, tag = "3")]
    pub query: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteStmt {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeallocateStmt {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub isall: bool,
    #[prost(int32, tag = "3")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropOwnedStmt {
    #[prost(message, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(enumeration = "DropBehavior", tag = "2")]
    pub behavior: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReassignOwnedStmt {
    #[prost(message, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "2")]
    pub newrole: ::core::option::Option<RoleSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTsDictionaryStmt {
    #[prost(message, repeated, tag = "1")]
    pub dictname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTsConfigurationStmt {
    #[prost(enumeration = "AlterTsConfigType", tag = "1")]
    pub kind: i32,
    #[prost(message, repeated, tag = "2")]
    pub cfgname: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub tokentype: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub dicts: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "5")]
    pub r#override: bool,
    #[prost(bool, tag = "6")]
    pub replace: bool,
    #[prost(bool, tag = "7")]
    pub missing_ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicationTable {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<RangeVar>,
    #[prost(message, optional, boxed, tag = "2")]
    pub where_clause: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    #[prost(message, repeated, tag = "3")]
    pub columns: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicationObjSpec {
    #[prost(enumeration = "PublicationObjSpecType", tag = "1")]
    pub pubobjtype: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "3")]
    pub pubtable: ::core::option::Option<::prost::alloc::boxed::Box<PublicationTable>>,
    #[prost(int32, tag = "4")]
    pub location: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePublicationStmt {
    #[prost(string, tag = "1")]
    pub pubname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub pubobjects: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub for_all_tables: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterPublicationStmt {
    #[prost(string, tag = "1")]
    pub pubname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "3")]
    pub pubobjects: ::prost::alloc::vec::Vec<Node>,
    #[prost(bool, tag = "4")]
    pub for_all_tables: bool,
    #[prost(enumeration = "AlterPublicationAction", tag = "5")]
    pub action: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubscriptionStmt {
    #[prost(string, tag = "1")]
    pub subname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub conninfo: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub publication: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterSubscriptionStmt {
    #[prost(enumeration = "AlterSubscriptionType", tag = "1")]
    pub kind: i32,
    #[prost(string, tag = "2")]
    pub subname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub conninfo: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub publication: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub options: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropSubscriptionStmt {
    #[prost(string, tag = "1")]
    pub subname: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub missing_ok: bool,
    #[prost(enumeration = "DropBehavior", tag = "3")]
    pub behavior: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScanToken {
    #[prost(int32, tag = "1")]
    pub start: i32,
    #[prost(int32, tag = "2")]
    pub end: i32,
    #[prost(enumeration = "Token", tag = "4")]
    pub token: i32,
    #[prost(enumeration = "KeywordKind", tag = "5")]
    pub keyword_kind: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuerySource {
    Undefined = 0,
    QsrcOriginal = 1,
    QsrcParser = 2,
    QsrcInsteadRule = 3,
    QsrcQualInsteadRule = 4,
    QsrcNonInsteadRule = 5,
}
impl QuerySource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "QUERY_SOURCE_UNDEFINED",
            Self::QsrcOriginal => "QSRC_ORIGINAL",
            Self::QsrcParser => "QSRC_PARSER",
            Self::QsrcInsteadRule => "QSRC_INSTEAD_RULE",
            Self::QsrcQualInsteadRule => "QSRC_QUAL_INSTEAD_RULE",
            Self::QsrcNonInsteadRule => "QSRC_NON_INSTEAD_RULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_SOURCE_UNDEFINED" => Some(Self::Undefined),
            "QSRC_ORIGINAL" => Some(Self::QsrcOriginal),
            "QSRC_PARSER" => Some(Self::QsrcParser),
            "QSRC_INSTEAD_RULE" => Some(Self::QsrcInsteadRule),
            "QSRC_QUAL_INSTEAD_RULE" => Some(Self::QsrcQualInsteadRule),
            "QSRC_NON_INSTEAD_RULE" => Some(Self::QsrcNonInsteadRule),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortByDir {
    Undefined = 0,
    SortbyDefault = 1,
    SortbyAsc = 2,
    SortbyDesc = 3,
    SortbyUsing = 4,
}
impl SortByDir {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SORT_BY_DIR_UNDEFINED",
            Self::SortbyDefault => "SORTBY_DEFAULT",
            Self::SortbyAsc => "SORTBY_ASC",
            Self::SortbyDesc => "SORTBY_DESC",
            Self::SortbyUsing => "SORTBY_USING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORT_BY_DIR_UNDEFINED" => Some(Self::Undefined),
            "SORTBY_DEFAULT" => Some(Self::SortbyDefault),
            "SORTBY_ASC" => Some(Self::SortbyAsc),
            "SORTBY_DESC" => Some(Self::SortbyDesc),
            "SORTBY_USING" => Some(Self::SortbyUsing),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortByNulls {
    Undefined = 0,
    SortbyNullsDefault = 1,
    SortbyNullsFirst = 2,
    SortbyNullsLast = 3,
}
impl SortByNulls {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SORT_BY_NULLS_UNDEFINED",
            Self::SortbyNullsDefault => "SORTBY_NULLS_DEFAULT",
            Self::SortbyNullsFirst => "SORTBY_NULLS_FIRST",
            Self::SortbyNullsLast => "SORTBY_NULLS_LAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORT_BY_NULLS_UNDEFINED" => Some(Self::Undefined),
            "SORTBY_NULLS_DEFAULT" => Some(Self::SortbyNullsDefault),
            "SORTBY_NULLS_FIRST" => Some(Self::SortbyNullsFirst),
            "SORTBY_NULLS_LAST" => Some(Self::SortbyNullsLast),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SetQuantifier {
    Undefined = 0,
    Default = 1,
    All = 2,
    Distinct = 3,
}
impl SetQuantifier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SET_QUANTIFIER_UNDEFINED",
            Self::Default => "SET_QUANTIFIER_DEFAULT",
            Self::All => "SET_QUANTIFIER_ALL",
            Self::Distinct => "SET_QUANTIFIER_DISTINCT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SET_QUANTIFIER_UNDEFINED" => Some(Self::Undefined),
            "SET_QUANTIFIER_DEFAULT" => Some(Self::Default),
            "SET_QUANTIFIER_ALL" => Some(Self::All),
            "SET_QUANTIFIER_DISTINCT" => Some(Self::Distinct),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AExprKind {
    Undefined = 0,
    AexprOp = 1,
    AexprOpAny = 2,
    AexprOpAll = 3,
    AexprDistinct = 4,
    AexprNotDistinct = 5,
    AexprNullif = 6,
    AexprIn = 7,
    AexprLike = 8,
    AexprIlike = 9,
    AexprSimilar = 10,
    AexprBetween = 11,
    AexprNotBetween = 12,
    AexprBetweenSym = 13,
    AexprNotBetweenSym = 14,
}
impl AExprKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "A_EXPR_KIND_UNDEFINED",
            Self::AexprOp => "AEXPR_OP",
            Self::AexprOpAny => "AEXPR_OP_ANY",
            Self::AexprOpAll => "AEXPR_OP_ALL",
            Self::AexprDistinct => "AEXPR_DISTINCT",
            Self::AexprNotDistinct => "AEXPR_NOT_DISTINCT",
            Self::AexprNullif => "AEXPR_NULLIF",
            Self::AexprIn => "AEXPR_IN",
            Self::AexprLike => "AEXPR_LIKE",
            Self::AexprIlike => "AEXPR_ILIKE",
            Self::AexprSimilar => "AEXPR_SIMILAR",
            Self::AexprBetween => "AEXPR_BETWEEN",
            Self::AexprNotBetween => "AEXPR_NOT_BETWEEN",
            Self::AexprBetweenSym => "AEXPR_BETWEEN_SYM",
            Self::AexprNotBetweenSym => "AEXPR_NOT_BETWEEN_SYM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "A_EXPR_KIND_UNDEFINED" => Some(Self::Undefined),
            "AEXPR_OP" => Some(Self::AexprOp),
            "AEXPR_OP_ANY" => Some(Self::AexprOpAny),
            "AEXPR_OP_ALL" => Some(Self::AexprOpAll),
            "AEXPR_DISTINCT" => Some(Self::AexprDistinct),
            "AEXPR_NOT_DISTINCT" => Some(Self::AexprNotDistinct),
            "AEXPR_NULLIF" => Some(Self::AexprNullif),
            "AEXPR_IN" => Some(Self::AexprIn),
            "AEXPR_LIKE" => Some(Self::AexprLike),
            "AEXPR_ILIKE" => Some(Self::AexprIlike),
            "AEXPR_SIMILAR" => Some(Self::AexprSimilar),
            "AEXPR_BETWEEN" => Some(Self::AexprBetween),
            "AEXPR_NOT_BETWEEN" => Some(Self::AexprNotBetween),
            "AEXPR_BETWEEN_SYM" => Some(Self::AexprBetweenSym),
            "AEXPR_NOT_BETWEEN_SYM" => Some(Self::AexprNotBetweenSym),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoleSpecType {
    Undefined = 0,
    RolespecCstring = 1,
    RolespecCurrentRole = 2,
    RolespecCurrentUser = 3,
    RolespecSessionUser = 4,
    RolespecPublic = 5,
}
impl RoleSpecType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ROLE_SPEC_TYPE_UNDEFINED",
            Self::RolespecCstring => "ROLESPEC_CSTRING",
            Self::RolespecCurrentRole => "ROLESPEC_CURRENT_ROLE",
            Self::RolespecCurrentUser => "ROLESPEC_CURRENT_USER",
            Self::RolespecSessionUser => "ROLESPEC_SESSION_USER",
            Self::RolespecPublic => "ROLESPEC_PUBLIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLE_SPEC_TYPE_UNDEFINED" => Some(Self::Undefined),
            "ROLESPEC_CSTRING" => Some(Self::RolespecCstring),
            "ROLESPEC_CURRENT_ROLE" => Some(Self::RolespecCurrentRole),
            "ROLESPEC_CURRENT_USER" => Some(Self::RolespecCurrentUser),
            "ROLESPEC_SESSION_USER" => Some(Self::RolespecSessionUser),
            "ROLESPEC_PUBLIC" => Some(Self::RolespecPublic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TableLikeOption {
    Undefined = 0,
    CreateTableLikeComments = 1,
    CreateTableLikeCompression = 2,
    CreateTableLikeConstraints = 3,
    CreateTableLikeDefaults = 4,
    CreateTableLikeGenerated = 5,
    CreateTableLikeIdentity = 6,
    CreateTableLikeIndexes = 7,
    CreateTableLikeStatistics = 8,
    CreateTableLikeStorage = 9,
    CreateTableLikeAll = 10,
}
impl TableLikeOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "TABLE_LIKE_OPTION_UNDEFINED",
            Self::CreateTableLikeComments => "CREATE_TABLE_LIKE_COMMENTS",
            Self::CreateTableLikeCompression => "CREATE_TABLE_LIKE_COMPRESSION",
            Self::CreateTableLikeConstraints => "CREATE_TABLE_LIKE_CONSTRAINTS",
            Self::CreateTableLikeDefaults => "CREATE_TABLE_LIKE_DEFAULTS",
            Self::CreateTableLikeGenerated => "CREATE_TABLE_LIKE_GENERATED",
            Self::CreateTableLikeIdentity => "CREATE_TABLE_LIKE_IDENTITY",
            Self::CreateTableLikeIndexes => "CREATE_TABLE_LIKE_INDEXES",
            Self::CreateTableLikeStatistics => "CREATE_TABLE_LIKE_STATISTICS",
            Self::CreateTableLikeStorage => "CREATE_TABLE_LIKE_STORAGE",
            Self::CreateTableLikeAll => "CREATE_TABLE_LIKE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLE_LIKE_OPTION_UNDEFINED" => Some(Self::Undefined),
            "CREATE_TABLE_LIKE_COMMENTS" => Some(Self::CreateTableLikeComments),
            "CREATE_TABLE_LIKE_COMPRESSION" => Some(Self::CreateTableLikeCompression),
            "CREATE_TABLE_LIKE_CONSTRAINTS" => Some(Self::CreateTableLikeConstraints),
            "CREATE_TABLE_LIKE_DEFAULTS" => Some(Self::CreateTableLikeDefaults),
            "CREATE_TABLE_LIKE_GENERATED" => Some(Self::CreateTableLikeGenerated),
            "CREATE_TABLE_LIKE_IDENTITY" => Some(Self::CreateTableLikeIdentity),
            "CREATE_TABLE_LIKE_INDEXES" => Some(Self::CreateTableLikeIndexes),
            "CREATE_TABLE_LIKE_STATISTICS" => Some(Self::CreateTableLikeStatistics),
            "CREATE_TABLE_LIKE_STORAGE" => Some(Self::CreateTableLikeStorage),
            "CREATE_TABLE_LIKE_ALL" => Some(Self::CreateTableLikeAll),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DefElemAction {
    Undefined = 0,
    DefelemUnspec = 1,
    DefelemSet = 2,
    DefelemAdd = 3,
    DefelemDrop = 4,
}
impl DefElemAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "DEF_ELEM_ACTION_UNDEFINED",
            Self::DefelemUnspec => "DEFELEM_UNSPEC",
            Self::DefelemSet => "DEFELEM_SET",
            Self::DefelemAdd => "DEFELEM_ADD",
            Self::DefelemDrop => "DEFELEM_DROP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEF_ELEM_ACTION_UNDEFINED" => Some(Self::Undefined),
            "DEFELEM_UNSPEC" => Some(Self::DefelemUnspec),
            "DEFELEM_SET" => Some(Self::DefelemSet),
            "DEFELEM_ADD" => Some(Self::DefelemAdd),
            "DEFELEM_DROP" => Some(Self::DefelemDrop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PartitionStrategy {
    Undefined = 0,
    List = 1,
    Range = 2,
    Hash = 3,
}
impl PartitionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "PARTITION_STRATEGY_UNDEFINED",
            Self::List => "PARTITION_STRATEGY_LIST",
            Self::Range => "PARTITION_STRATEGY_RANGE",
            Self::Hash => "PARTITION_STRATEGY_HASH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTITION_STRATEGY_UNDEFINED" => Some(Self::Undefined),
            "PARTITION_STRATEGY_LIST" => Some(Self::List),
            "PARTITION_STRATEGY_RANGE" => Some(Self::Range),
            "PARTITION_STRATEGY_HASH" => Some(Self::Hash),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PartitionRangeDatumKind {
    Undefined = 0,
    PartitionRangeDatumMinvalue = 1,
    PartitionRangeDatumValue = 2,
    PartitionRangeDatumMaxvalue = 3,
}
impl PartitionRangeDatumKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "PARTITION_RANGE_DATUM_KIND_UNDEFINED",
            Self::PartitionRangeDatumMinvalue => "PARTITION_RANGE_DATUM_MINVALUE",
            Self::PartitionRangeDatumValue => "PARTITION_RANGE_DATUM_VALUE",
            Self::PartitionRangeDatumMaxvalue => "PARTITION_RANGE_DATUM_MAXVALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTITION_RANGE_DATUM_KIND_UNDEFINED" => Some(Self::Undefined),
            "PARTITION_RANGE_DATUM_MINVALUE" => Some(Self::PartitionRangeDatumMinvalue),
            "PARTITION_RANGE_DATUM_VALUE" => Some(Self::PartitionRangeDatumValue),
            "PARTITION_RANGE_DATUM_MAXVALUE" => Some(Self::PartitionRangeDatumMaxvalue),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RteKind {
    RtekindUndefined = 0,
    RteRelation = 1,
    RteSubquery = 2,
    RteJoin = 3,
    RteFunction = 4,
    RteTablefunc = 5,
    RteValues = 6,
    RteCte = 7,
    RteNamedtuplestore = 8,
    RteResult = 9,
}
impl RteKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RtekindUndefined => "RTEKIND_UNDEFINED",
            Self::RteRelation => "RTE_RELATION",
            Self::RteSubquery => "RTE_SUBQUERY",
            Self::RteJoin => "RTE_JOIN",
            Self::RteFunction => "RTE_FUNCTION",
            Self::RteTablefunc => "RTE_TABLEFUNC",
            Self::RteValues => "RTE_VALUES",
            Self::RteCte => "RTE_CTE",
            Self::RteNamedtuplestore => "RTE_NAMEDTUPLESTORE",
            Self::RteResult => "RTE_RESULT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RTEKIND_UNDEFINED" => Some(Self::RtekindUndefined),
            "RTE_RELATION" => Some(Self::RteRelation),
            "RTE_SUBQUERY" => Some(Self::RteSubquery),
            "RTE_JOIN" => Some(Self::RteJoin),
            "RTE_FUNCTION" => Some(Self::RteFunction),
            "RTE_TABLEFUNC" => Some(Self::RteTablefunc),
            "RTE_VALUES" => Some(Self::RteValues),
            "RTE_CTE" => Some(Self::RteCte),
            "RTE_NAMEDTUPLESTORE" => Some(Self::RteNamedtuplestore),
            "RTE_RESULT" => Some(Self::RteResult),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WcoKind {
    WcokindUndefined = 0,
    WcoViewCheck = 1,
    WcoRlsInsertCheck = 2,
    WcoRlsUpdateCheck = 3,
    WcoRlsConflictCheck = 4,
    WcoRlsMergeUpdateCheck = 5,
    WcoRlsMergeDeleteCheck = 6,
}
impl WcoKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::WcokindUndefined => "WCOKIND_UNDEFINED",
            Self::WcoViewCheck => "WCO_VIEW_CHECK",
            Self::WcoRlsInsertCheck => "WCO_RLS_INSERT_CHECK",
            Self::WcoRlsUpdateCheck => "WCO_RLS_UPDATE_CHECK",
            Self::WcoRlsConflictCheck => "WCO_RLS_CONFLICT_CHECK",
            Self::WcoRlsMergeUpdateCheck => "WCO_RLS_MERGE_UPDATE_CHECK",
            Self::WcoRlsMergeDeleteCheck => "WCO_RLS_MERGE_DELETE_CHECK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WCOKIND_UNDEFINED" => Some(Self::WcokindUndefined),
            "WCO_VIEW_CHECK" => Some(Self::WcoViewCheck),
            "WCO_RLS_INSERT_CHECK" => Some(Self::WcoRlsInsertCheck),
            "WCO_RLS_UPDATE_CHECK" => Some(Self::WcoRlsUpdateCheck),
            "WCO_RLS_CONFLICT_CHECK" => Some(Self::WcoRlsConflictCheck),
            "WCO_RLS_MERGE_UPDATE_CHECK" => Some(Self::WcoRlsMergeUpdateCheck),
            "WCO_RLS_MERGE_DELETE_CHECK" => Some(Self::WcoRlsMergeDeleteCheck),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupingSetKind {
    Undefined = 0,
    GroupingSetEmpty = 1,
    GroupingSetSimple = 2,
    GroupingSetRollup = 3,
    GroupingSetCube = 4,
    GroupingSetSets = 5,
}
impl GroupingSetKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "GROUPING_SET_KIND_UNDEFINED",
            Self::GroupingSetEmpty => "GROUPING_SET_EMPTY",
            Self::GroupingSetSimple => "GROUPING_SET_SIMPLE",
            Self::GroupingSetRollup => "GROUPING_SET_ROLLUP",
            Self::GroupingSetCube => "GROUPING_SET_CUBE",
            Self::GroupingSetSets => "GROUPING_SET_SETS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GROUPING_SET_KIND_UNDEFINED" => Some(Self::Undefined),
            "GROUPING_SET_EMPTY" => Some(Self::GroupingSetEmpty),
            "GROUPING_SET_SIMPLE" => Some(Self::GroupingSetSimple),
            "GROUPING_SET_ROLLUP" => Some(Self::GroupingSetRollup),
            "GROUPING_SET_CUBE" => Some(Self::GroupingSetCube),
            "GROUPING_SET_SETS" => Some(Self::GroupingSetSets),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CteMaterialize {
    CtematerializeUndefined = 0,
    Default = 1,
    Always = 2,
    Never = 3,
}
impl CteMaterialize {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CtematerializeUndefined => "CTEMATERIALIZE_UNDEFINED",
            Self::Default => "CTEMaterializeDefault",
            Self::Always => "CTEMaterializeAlways",
            Self::Never => "CTEMaterializeNever",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CTEMATERIALIZE_UNDEFINED" => Some(Self::CtematerializeUndefined),
            "CTEMaterializeDefault" => Some(Self::Default),
            "CTEMaterializeAlways" => Some(Self::Always),
            "CTEMaterializeNever" => Some(Self::Never),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonQuotes {
    Undefined = 0,
    JsQuotesUnspec = 1,
    JsQuotesKeep = 2,
    JsQuotesOmit = 3,
}
impl JsonQuotes {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_QUOTES_UNDEFINED",
            Self::JsQuotesUnspec => "JS_QUOTES_UNSPEC",
            Self::JsQuotesKeep => "JS_QUOTES_KEEP",
            Self::JsQuotesOmit => "JS_QUOTES_OMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_QUOTES_UNDEFINED" => Some(Self::Undefined),
            "JS_QUOTES_UNSPEC" => Some(Self::JsQuotesUnspec),
            "JS_QUOTES_KEEP" => Some(Self::JsQuotesKeep),
            "JS_QUOTES_OMIT" => Some(Self::JsQuotesOmit),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonTableColumnType {
    Undefined = 0,
    JtcForOrdinality = 1,
    JtcRegular = 2,
    JtcExists = 3,
    JtcFormatted = 4,
    JtcNested = 5,
}
impl JsonTableColumnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_TABLE_COLUMN_TYPE_UNDEFINED",
            Self::JtcForOrdinality => "JTC_FOR_ORDINALITY",
            Self::JtcRegular => "JTC_REGULAR",
            Self::JtcExists => "JTC_EXISTS",
            Self::JtcFormatted => "JTC_FORMATTED",
            Self::JtcNested => "JTC_NESTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_TABLE_COLUMN_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JTC_FOR_ORDINALITY" => Some(Self::JtcForOrdinality),
            "JTC_REGULAR" => Some(Self::JtcRegular),
            "JTC_EXISTS" => Some(Self::JtcExists),
            "JTC_FORMATTED" => Some(Self::JtcFormatted),
            "JTC_NESTED" => Some(Self::JtcNested),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SetOperation {
    Undefined = 0,
    SetopNone = 1,
    SetopUnion = 2,
    SetopIntersect = 3,
    SetopExcept = 4,
}
impl SetOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SET_OPERATION_UNDEFINED",
            Self::SetopNone => "SETOP_NONE",
            Self::SetopUnion => "SETOP_UNION",
            Self::SetopIntersect => "SETOP_INTERSECT",
            Self::SetopExcept => "SETOP_EXCEPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SET_OPERATION_UNDEFINED" => Some(Self::Undefined),
            "SETOP_NONE" => Some(Self::SetopNone),
            "SETOP_UNION" => Some(Self::SetopUnion),
            "SETOP_INTERSECT" => Some(Self::SetopIntersect),
            "SETOP_EXCEPT" => Some(Self::SetopExcept),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ObjectType {
    Undefined = 0,
    ObjectAccessMethod = 1,
    ObjectAggregate = 2,
    ObjectAmop = 3,
    ObjectAmproc = 4,
    ObjectAttribute = 5,
    ObjectCast = 6,
    ObjectColumn = 7,
    ObjectCollation = 8,
    ObjectConversion = 9,
    ObjectDatabase = 10,
    ObjectDefault = 11,
    ObjectDefacl = 12,
    ObjectDomain = 13,
    ObjectDomconstraint = 14,
    ObjectEventTrigger = 15,
    ObjectExtension = 16,
    ObjectFdw = 17,
    ObjectForeignServer = 18,
    ObjectForeignTable = 19,
    ObjectFunction = 20,
    ObjectIndex = 21,
    ObjectLanguage = 22,
    ObjectLargeobject = 23,
    ObjectMatview = 24,
    ObjectOpclass = 25,
    ObjectOperator = 26,
    ObjectOpfamily = 27,
    ObjectParameterAcl = 28,
    ObjectPolicy = 29,
    ObjectProcedure = 30,
    ObjectPublication = 31,
    ObjectPublicationNamespace = 32,
    ObjectPublicationRel = 33,
    ObjectRole = 34,
    ObjectRoutine = 35,
    ObjectRule = 36,
    ObjectSchema = 37,
    ObjectSequence = 38,
    ObjectSubscription = 39,
    ObjectStatisticExt = 40,
    ObjectTabconstraint = 41,
    ObjectTable = 42,
    ObjectTablespace = 43,
    ObjectTransform = 44,
    ObjectTrigger = 45,
    ObjectTsconfiguration = 46,
    ObjectTsdictionary = 47,
    ObjectTsparser = 48,
    ObjectTstemplate = 49,
    ObjectType = 50,
    ObjectUserMapping = 51,
    ObjectView = 52,
}
impl ObjectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "OBJECT_TYPE_UNDEFINED",
            Self::ObjectAccessMethod => "OBJECT_ACCESS_METHOD",
            Self::ObjectAggregate => "OBJECT_AGGREGATE",
            Self::ObjectAmop => "OBJECT_AMOP",
            Self::ObjectAmproc => "OBJECT_AMPROC",
            Self::ObjectAttribute => "OBJECT_ATTRIBUTE",
            Self::ObjectCast => "OBJECT_CAST",
            Self::ObjectColumn => "OBJECT_COLUMN",
            Self::ObjectCollation => "OBJECT_COLLATION",
            Self::ObjectConversion => "OBJECT_CONVERSION",
            Self::ObjectDatabase => "OBJECT_DATABASE",
            Self::ObjectDefault => "OBJECT_DEFAULT",
            Self::ObjectDefacl => "OBJECT_DEFACL",
            Self::ObjectDomain => "OBJECT_DOMAIN",
            Self::ObjectDomconstraint => "OBJECT_DOMCONSTRAINT",
            Self::ObjectEventTrigger => "OBJECT_EVENT_TRIGGER",
            Self::ObjectExtension => "OBJECT_EXTENSION",
            Self::ObjectFdw => "OBJECT_FDW",
            Self::ObjectForeignServer => "OBJECT_FOREIGN_SERVER",
            Self::ObjectForeignTable => "OBJECT_FOREIGN_TABLE",
            Self::ObjectFunction => "OBJECT_FUNCTION",
            Self::ObjectIndex => "OBJECT_INDEX",
            Self::ObjectLanguage => "OBJECT_LANGUAGE",
            Self::ObjectLargeobject => "OBJECT_LARGEOBJECT",
            Self::ObjectMatview => "OBJECT_MATVIEW",
            Self::ObjectOpclass => "OBJECT_OPCLASS",
            Self::ObjectOperator => "OBJECT_OPERATOR",
            Self::ObjectOpfamily => "OBJECT_OPFAMILY",
            Self::ObjectParameterAcl => "OBJECT_PARAMETER_ACL",
            Self::ObjectPolicy => "OBJECT_POLICY",
            Self::ObjectProcedure => "OBJECT_PROCEDURE",
            Self::ObjectPublication => "OBJECT_PUBLICATION",
            Self::ObjectPublicationNamespace => "OBJECT_PUBLICATION_NAMESPACE",
            Self::ObjectPublicationRel => "OBJECT_PUBLICATION_REL",
            Self::ObjectRole => "OBJECT_ROLE",
            Self::ObjectRoutine => "OBJECT_ROUTINE",
            Self::ObjectRule => "OBJECT_RULE",
            Self::ObjectSchema => "OBJECT_SCHEMA",
            Self::ObjectSequence => "OBJECT_SEQUENCE",
            Self::ObjectSubscription => "OBJECT_SUBSCRIPTION",
            Self::ObjectStatisticExt => "OBJECT_STATISTIC_EXT",
            Self::ObjectTabconstraint => "OBJECT_TABCONSTRAINT",
            Self::ObjectTable => "OBJECT_TABLE",
            Self::ObjectTablespace => "OBJECT_TABLESPACE",
            Self::ObjectTransform => "OBJECT_TRANSFORM",
            Self::ObjectTrigger => "OBJECT_TRIGGER",
            Self::ObjectTsconfiguration => "OBJECT_TSCONFIGURATION",
            Self::ObjectTsdictionary => "OBJECT_TSDICTIONARY",
            Self::ObjectTsparser => "OBJECT_TSPARSER",
            Self::ObjectTstemplate => "OBJECT_TSTEMPLATE",
            Self::ObjectType => "OBJECT_TYPE",
            Self::ObjectUserMapping => "OBJECT_USER_MAPPING",
            Self::ObjectView => "OBJECT_VIEW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OBJECT_TYPE_UNDEFINED" => Some(Self::Undefined),
            "OBJECT_ACCESS_METHOD" => Some(Self::ObjectAccessMethod),
            "OBJECT_AGGREGATE" => Some(Self::ObjectAggregate),
            "OBJECT_AMOP" => Some(Self::ObjectAmop),
            "OBJECT_AMPROC" => Some(Self::ObjectAmproc),
            "OBJECT_ATTRIBUTE" => Some(Self::ObjectAttribute),
            "OBJECT_CAST" => Some(Self::ObjectCast),
            "OBJECT_COLUMN" => Some(Self::ObjectColumn),
            "OBJECT_COLLATION" => Some(Self::ObjectCollation),
            "OBJECT_CONVERSION" => Some(Self::ObjectConversion),
            "OBJECT_DATABASE" => Some(Self::ObjectDatabase),
            "OBJECT_DEFAULT" => Some(Self::ObjectDefault),
            "OBJECT_DEFACL" => Some(Self::ObjectDefacl),
            "OBJECT_DOMAIN" => Some(Self::ObjectDomain),
            "OBJECT_DOMCONSTRAINT" => Some(Self::ObjectDomconstraint),
            "OBJECT_EVENT_TRIGGER" => Some(Self::ObjectEventTrigger),
            "OBJECT_EXTENSION" => Some(Self::ObjectExtension),
            "OBJECT_FDW" => Some(Self::ObjectFdw),
            "OBJECT_FOREIGN_SERVER" => Some(Self::ObjectForeignServer),
            "OBJECT_FOREIGN_TABLE" => Some(Self::ObjectForeignTable),
            "OBJECT_FUNCTION" => Some(Self::ObjectFunction),
            "OBJECT_INDEX" => Some(Self::ObjectIndex),
            "OBJECT_LANGUAGE" => Some(Self::ObjectLanguage),
            "OBJECT_LARGEOBJECT" => Some(Self::ObjectLargeobject),
            "OBJECT_MATVIEW" => Some(Self::ObjectMatview),
            "OBJECT_OPCLASS" => Some(Self::ObjectOpclass),
            "OBJECT_OPERATOR" => Some(Self::ObjectOperator),
            "OBJECT_OPFAMILY" => Some(Self::ObjectOpfamily),
            "OBJECT_PARAMETER_ACL" => Some(Self::ObjectParameterAcl),
            "OBJECT_POLICY" => Some(Self::ObjectPolicy),
            "OBJECT_PROCEDURE" => Some(Self::ObjectProcedure),
            "OBJECT_PUBLICATION" => Some(Self::ObjectPublication),
            "OBJECT_PUBLICATION_NAMESPACE" => Some(Self::ObjectPublicationNamespace),
            "OBJECT_PUBLICATION_REL" => Some(Self::ObjectPublicationRel),
            "OBJECT_ROLE" => Some(Self::ObjectRole),
            "OBJECT_ROUTINE" => Some(Self::ObjectRoutine),
            "OBJECT_RULE" => Some(Self::ObjectRule),
            "OBJECT_SCHEMA" => Some(Self::ObjectSchema),
            "OBJECT_SEQUENCE" => Some(Self::ObjectSequence),
            "OBJECT_SUBSCRIPTION" => Some(Self::ObjectSubscription),
            "OBJECT_STATISTIC_EXT" => Some(Self::ObjectStatisticExt),
            "OBJECT_TABCONSTRAINT" => Some(Self::ObjectTabconstraint),
            "OBJECT_TABLE" => Some(Self::ObjectTable),
            "OBJECT_TABLESPACE" => Some(Self::ObjectTablespace),
            "OBJECT_TRANSFORM" => Some(Self::ObjectTransform),
            "OBJECT_TRIGGER" => Some(Self::ObjectTrigger),
            "OBJECT_TSCONFIGURATION" => Some(Self::ObjectTsconfiguration),
            "OBJECT_TSDICTIONARY" => Some(Self::ObjectTsdictionary),
            "OBJECT_TSPARSER" => Some(Self::ObjectTsparser),
            "OBJECT_TSTEMPLATE" => Some(Self::ObjectTstemplate),
            "OBJECT_TYPE" => Some(Self::ObjectType),
            "OBJECT_USER_MAPPING" => Some(Self::ObjectUserMapping),
            "OBJECT_VIEW" => Some(Self::ObjectView),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DropBehavior {
    Undefined = 0,
    DropRestrict = 1,
    DropCascade = 2,
}
impl DropBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "DROP_BEHAVIOR_UNDEFINED",
            Self::DropRestrict => "DROP_RESTRICT",
            Self::DropCascade => "DROP_CASCADE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DROP_BEHAVIOR_UNDEFINED" => Some(Self::Undefined),
            "DROP_RESTRICT" => Some(Self::DropRestrict),
            "DROP_CASCADE" => Some(Self::DropCascade),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlterTableType {
    Undefined = 0,
    AtAddColumn = 1,
    AtAddColumnToView = 2,
    AtColumnDefault = 3,
    AtCookedColumnDefault = 4,
    AtDropNotNull = 5,
    AtSetNotNull = 6,
    AtSetExpression = 7,
    AtDropExpression = 8,
    AtCheckNotNull = 9,
    AtSetStatistics = 10,
    AtSetOptions = 11,
    AtResetOptions = 12,
    AtSetStorage = 13,
    AtSetCompression = 14,
    AtDropColumn = 15,
    AtAddIndex = 16,
    AtReAddIndex = 17,
    AtAddConstraint = 18,
    AtReAddConstraint = 19,
    AtReAddDomainConstraint = 20,
    AtAlterConstraint = 21,
    AtValidateConstraint = 22,
    AtAddIndexConstraint = 23,
    AtDropConstraint = 24,
    AtReAddComment = 25,
    AtAlterColumnType = 26,
    AtAlterColumnGenericOptions = 27,
    AtChangeOwner = 28,
    AtClusterOn = 29,
    AtDropCluster = 30,
    AtSetLogged = 31,
    AtSetUnLogged = 32,
    AtDropOids = 33,
    AtSetAccessMethod = 34,
    AtSetTableSpace = 35,
    AtSetRelOptions = 36,
    AtResetRelOptions = 37,
    AtReplaceRelOptions = 38,
    AtEnableTrig = 39,
    AtEnableAlwaysTrig = 40,
    AtEnableReplicaTrig = 41,
    AtDisableTrig = 42,
    AtEnableTrigAll = 43,
    AtDisableTrigAll = 44,
    AtEnableTrigUser = 45,
    AtDisableTrigUser = 46,
    AtEnableRule = 47,
    AtEnableAlwaysRule = 48,
    AtEnableReplicaRule = 49,
    AtDisableRule = 50,
    AtAddInherit = 51,
    AtDropInherit = 52,
    AtAddOf = 53,
    AtDropOf = 54,
    AtReplicaIdentity = 55,
    AtEnableRowSecurity = 56,
    AtDisableRowSecurity = 57,
    AtForceRowSecurity = 58,
    AtNoForceRowSecurity = 59,
    AtGenericOptions = 60,
    AtAttachPartition = 61,
    AtDetachPartition = 62,
    AtDetachPartitionFinalize = 63,
    AtAddIdentity = 64,
    AtSetIdentity = 65,
    AtDropIdentity = 66,
    AtReAddStatistics = 67,
}
impl AlterTableType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ALTER_TABLE_TYPE_UNDEFINED",
            Self::AtAddColumn => "AT_AddColumn",
            Self::AtAddColumnToView => "AT_AddColumnToView",
            Self::AtColumnDefault => "AT_ColumnDefault",
            Self::AtCookedColumnDefault => "AT_CookedColumnDefault",
            Self::AtDropNotNull => "AT_DropNotNull",
            Self::AtSetNotNull => "AT_SetNotNull",
            Self::AtSetExpression => "AT_SetExpression",
            Self::AtDropExpression => "AT_DropExpression",
            Self::AtCheckNotNull => "AT_CheckNotNull",
            Self::AtSetStatistics => "AT_SetStatistics",
            Self::AtSetOptions => "AT_SetOptions",
            Self::AtResetOptions => "AT_ResetOptions",
            Self::AtSetStorage => "AT_SetStorage",
            Self::AtSetCompression => "AT_SetCompression",
            Self::AtDropColumn => "AT_DropColumn",
            Self::AtAddIndex => "AT_AddIndex",
            Self::AtReAddIndex => "AT_ReAddIndex",
            Self::AtAddConstraint => "AT_AddConstraint",
            Self::AtReAddConstraint => "AT_ReAddConstraint",
            Self::AtReAddDomainConstraint => "AT_ReAddDomainConstraint",
            Self::AtAlterConstraint => "AT_AlterConstraint",
            Self::AtValidateConstraint => "AT_ValidateConstraint",
            Self::AtAddIndexConstraint => "AT_AddIndexConstraint",
            Self::AtDropConstraint => "AT_DropConstraint",
            Self::AtReAddComment => "AT_ReAddComment",
            Self::AtAlterColumnType => "AT_AlterColumnType",
            Self::AtAlterColumnGenericOptions => "AT_AlterColumnGenericOptions",
            Self::AtChangeOwner => "AT_ChangeOwner",
            Self::AtClusterOn => "AT_ClusterOn",
            Self::AtDropCluster => "AT_DropCluster",
            Self::AtSetLogged => "AT_SetLogged",
            Self::AtSetUnLogged => "AT_SetUnLogged",
            Self::AtDropOids => "AT_DropOids",
            Self::AtSetAccessMethod => "AT_SetAccessMethod",
            Self::AtSetTableSpace => "AT_SetTableSpace",
            Self::AtSetRelOptions => "AT_SetRelOptions",
            Self::AtResetRelOptions => "AT_ResetRelOptions",
            Self::AtReplaceRelOptions => "AT_ReplaceRelOptions",
            Self::AtEnableTrig => "AT_EnableTrig",
            Self::AtEnableAlwaysTrig => "AT_EnableAlwaysTrig",
            Self::AtEnableReplicaTrig => "AT_EnableReplicaTrig",
            Self::AtDisableTrig => "AT_DisableTrig",
            Self::AtEnableTrigAll => "AT_EnableTrigAll",
            Self::AtDisableTrigAll => "AT_DisableTrigAll",
            Self::AtEnableTrigUser => "AT_EnableTrigUser",
            Self::AtDisableTrigUser => "AT_DisableTrigUser",
            Self::AtEnableRule => "AT_EnableRule",
            Self::AtEnableAlwaysRule => "AT_EnableAlwaysRule",
            Self::AtEnableReplicaRule => "AT_EnableReplicaRule",
            Self::AtDisableRule => "AT_DisableRule",
            Self::AtAddInherit => "AT_AddInherit",
            Self::AtDropInherit => "AT_DropInherit",
            Self::AtAddOf => "AT_AddOf",
            Self::AtDropOf => "AT_DropOf",
            Self::AtReplicaIdentity => "AT_ReplicaIdentity",
            Self::AtEnableRowSecurity => "AT_EnableRowSecurity",
            Self::AtDisableRowSecurity => "AT_DisableRowSecurity",
            Self::AtForceRowSecurity => "AT_ForceRowSecurity",
            Self::AtNoForceRowSecurity => "AT_NoForceRowSecurity",
            Self::AtGenericOptions => "AT_GenericOptions",
            Self::AtAttachPartition => "AT_AttachPartition",
            Self::AtDetachPartition => "AT_DetachPartition",
            Self::AtDetachPartitionFinalize => "AT_DetachPartitionFinalize",
            Self::AtAddIdentity => "AT_AddIdentity",
            Self::AtSetIdentity => "AT_SetIdentity",
            Self::AtDropIdentity => "AT_DropIdentity",
            Self::AtReAddStatistics => "AT_ReAddStatistics",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALTER_TABLE_TYPE_UNDEFINED" => Some(Self::Undefined),
            "AT_AddColumn" => Some(Self::AtAddColumn),
            "AT_AddColumnToView" => Some(Self::AtAddColumnToView),
            "AT_ColumnDefault" => Some(Self::AtColumnDefault),
            "AT_CookedColumnDefault" => Some(Self::AtCookedColumnDefault),
            "AT_DropNotNull" => Some(Self::AtDropNotNull),
            "AT_SetNotNull" => Some(Self::AtSetNotNull),
            "AT_SetExpression" => Some(Self::AtSetExpression),
            "AT_DropExpression" => Some(Self::AtDropExpression),
            "AT_CheckNotNull" => Some(Self::AtCheckNotNull),
            "AT_SetStatistics" => Some(Self::AtSetStatistics),
            "AT_SetOptions" => Some(Self::AtSetOptions),
            "AT_ResetOptions" => Some(Self::AtResetOptions),
            "AT_SetStorage" => Some(Self::AtSetStorage),
            "AT_SetCompression" => Some(Self::AtSetCompression),
            "AT_DropColumn" => Some(Self::AtDropColumn),
            "AT_AddIndex" => Some(Self::AtAddIndex),
            "AT_ReAddIndex" => Some(Self::AtReAddIndex),
            "AT_AddConstraint" => Some(Self::AtAddConstraint),
            "AT_ReAddConstraint" => Some(Self::AtReAddConstraint),
            "AT_ReAddDomainConstraint" => Some(Self::AtReAddDomainConstraint),
            "AT_AlterConstraint" => Some(Self::AtAlterConstraint),
            "AT_ValidateConstraint" => Some(Self::AtValidateConstraint),
            "AT_AddIndexConstraint" => Some(Self::AtAddIndexConstraint),
            "AT_DropConstraint" => Some(Self::AtDropConstraint),
            "AT_ReAddComment" => Some(Self::AtReAddComment),
            "AT_AlterColumnType" => Some(Self::AtAlterColumnType),
            "AT_AlterColumnGenericOptions" => Some(Self::AtAlterColumnGenericOptions),
            "AT_ChangeOwner" => Some(Self::AtChangeOwner),
            "AT_ClusterOn" => Some(Self::AtClusterOn),
            "AT_DropCluster" => Some(Self::AtDropCluster),
            "AT_SetLogged" => Some(Self::AtSetLogged),
            "AT_SetUnLogged" => Some(Self::AtSetUnLogged),
            "AT_DropOids" => Some(Self::AtDropOids),
            "AT_SetAccessMethod" => Some(Self::AtSetAccessMethod),
            "AT_SetTableSpace" => Some(Self::AtSetTableSpace),
            "AT_SetRelOptions" => Some(Self::AtSetRelOptions),
            "AT_ResetRelOptions" => Some(Self::AtResetRelOptions),
            "AT_ReplaceRelOptions" => Some(Self::AtReplaceRelOptions),
            "AT_EnableTrig" => Some(Self::AtEnableTrig),
            "AT_EnableAlwaysTrig" => Some(Self::AtEnableAlwaysTrig),
            "AT_EnableReplicaTrig" => Some(Self::AtEnableReplicaTrig),
            "AT_DisableTrig" => Some(Self::AtDisableTrig),
            "AT_EnableTrigAll" => Some(Self::AtEnableTrigAll),
            "AT_DisableTrigAll" => Some(Self::AtDisableTrigAll),
            "AT_EnableTrigUser" => Some(Self::AtEnableTrigUser),
            "AT_DisableTrigUser" => Some(Self::AtDisableTrigUser),
            "AT_EnableRule" => Some(Self::AtEnableRule),
            "AT_EnableAlwaysRule" => Some(Self::AtEnableAlwaysRule),
            "AT_EnableReplicaRule" => Some(Self::AtEnableReplicaRule),
            "AT_DisableRule" => Some(Self::AtDisableRule),
            "AT_AddInherit" => Some(Self::AtAddInherit),
            "AT_DropInherit" => Some(Self::AtDropInherit),
            "AT_AddOf" => Some(Self::AtAddOf),
            "AT_DropOf" => Some(Self::AtDropOf),
            "AT_ReplicaIdentity" => Some(Self::AtReplicaIdentity),
            "AT_EnableRowSecurity" => Some(Self::AtEnableRowSecurity),
            "AT_DisableRowSecurity" => Some(Self::AtDisableRowSecurity),
            "AT_ForceRowSecurity" => Some(Self::AtForceRowSecurity),
            "AT_NoForceRowSecurity" => Some(Self::AtNoForceRowSecurity),
            "AT_GenericOptions" => Some(Self::AtGenericOptions),
            "AT_AttachPartition" => Some(Self::AtAttachPartition),
            "AT_DetachPartition" => Some(Self::AtDetachPartition),
            "AT_DetachPartitionFinalize" => Some(Self::AtDetachPartitionFinalize),
            "AT_AddIdentity" => Some(Self::AtAddIdentity),
            "AT_SetIdentity" => Some(Self::AtSetIdentity),
            "AT_DropIdentity" => Some(Self::AtDropIdentity),
            "AT_ReAddStatistics" => Some(Self::AtReAddStatistics),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GrantTargetType {
    Undefined = 0,
    AclTargetObject = 1,
    AclTargetAllInSchema = 2,
    AclTargetDefaults = 3,
}
impl GrantTargetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "GRANT_TARGET_TYPE_UNDEFINED",
            Self::AclTargetObject => "ACL_TARGET_OBJECT",
            Self::AclTargetAllInSchema => "ACL_TARGET_ALL_IN_SCHEMA",
            Self::AclTargetDefaults => "ACL_TARGET_DEFAULTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRANT_TARGET_TYPE_UNDEFINED" => Some(Self::Undefined),
            "ACL_TARGET_OBJECT" => Some(Self::AclTargetObject),
            "ACL_TARGET_ALL_IN_SCHEMA" => Some(Self::AclTargetAllInSchema),
            "ACL_TARGET_DEFAULTS" => Some(Self::AclTargetDefaults),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VariableSetKind {
    Undefined = 0,
    VarSetValue = 1,
    VarSetDefault = 2,
    VarSetCurrent = 3,
    VarSetMulti = 4,
    VarReset = 5,
    VarResetAll = 6,
}
impl VariableSetKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "VARIABLE_SET_KIND_UNDEFINED",
            Self::VarSetValue => "VAR_SET_VALUE",
            Self::VarSetDefault => "VAR_SET_DEFAULT",
            Self::VarSetCurrent => "VAR_SET_CURRENT",
            Self::VarSetMulti => "VAR_SET_MULTI",
            Self::VarReset => "VAR_RESET",
            Self::VarResetAll => "VAR_RESET_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VARIABLE_SET_KIND_UNDEFINED" => Some(Self::Undefined),
            "VAR_SET_VALUE" => Some(Self::VarSetValue),
            "VAR_SET_DEFAULT" => Some(Self::VarSetDefault),
            "VAR_SET_CURRENT" => Some(Self::VarSetCurrent),
            "VAR_SET_MULTI" => Some(Self::VarSetMulti),
            "VAR_RESET" => Some(Self::VarReset),
            "VAR_RESET_ALL" => Some(Self::VarResetAll),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConstrType {
    Undefined = 0,
    ConstrNull = 1,
    ConstrNotnull = 2,
    ConstrDefault = 3,
    ConstrIdentity = 4,
    ConstrGenerated = 5,
    ConstrCheck = 6,
    ConstrPrimary = 7,
    ConstrUnique = 8,
    ConstrExclusion = 9,
    ConstrForeign = 10,
    ConstrAttrDeferrable = 11,
    ConstrAttrNotDeferrable = 12,
    ConstrAttrDeferred = 13,
    ConstrAttrImmediate = 14,
}
impl ConstrType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "CONSTR_TYPE_UNDEFINED",
            Self::ConstrNull => "CONSTR_NULL",
            Self::ConstrNotnull => "CONSTR_NOTNULL",
            Self::ConstrDefault => "CONSTR_DEFAULT",
            Self::ConstrIdentity => "CONSTR_IDENTITY",
            Self::ConstrGenerated => "CONSTR_GENERATED",
            Self::ConstrCheck => "CONSTR_CHECK",
            Self::ConstrPrimary => "CONSTR_PRIMARY",
            Self::ConstrUnique => "CONSTR_UNIQUE",
            Self::ConstrExclusion => "CONSTR_EXCLUSION",
            Self::ConstrForeign => "CONSTR_FOREIGN",
            Self::ConstrAttrDeferrable => "CONSTR_ATTR_DEFERRABLE",
            Self::ConstrAttrNotDeferrable => "CONSTR_ATTR_NOT_DEFERRABLE",
            Self::ConstrAttrDeferred => "CONSTR_ATTR_DEFERRED",
            Self::ConstrAttrImmediate => "CONSTR_ATTR_IMMEDIATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSTR_TYPE_UNDEFINED" => Some(Self::Undefined),
            "CONSTR_NULL" => Some(Self::ConstrNull),
            "CONSTR_NOTNULL" => Some(Self::ConstrNotnull),
            "CONSTR_DEFAULT" => Some(Self::ConstrDefault),
            "CONSTR_IDENTITY" => Some(Self::ConstrIdentity),
            "CONSTR_GENERATED" => Some(Self::ConstrGenerated),
            "CONSTR_CHECK" => Some(Self::ConstrCheck),
            "CONSTR_PRIMARY" => Some(Self::ConstrPrimary),
            "CONSTR_UNIQUE" => Some(Self::ConstrUnique),
            "CONSTR_EXCLUSION" => Some(Self::ConstrExclusion),
            "CONSTR_FOREIGN" => Some(Self::ConstrForeign),
            "CONSTR_ATTR_DEFERRABLE" => Some(Self::ConstrAttrDeferrable),
            "CONSTR_ATTR_NOT_DEFERRABLE" => Some(Self::ConstrAttrNotDeferrable),
            "CONSTR_ATTR_DEFERRED" => Some(Self::ConstrAttrDeferred),
            "CONSTR_ATTR_IMMEDIATE" => Some(Self::ConstrAttrImmediate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImportForeignSchemaType {
    Undefined = 0,
    FdwImportSchemaAll = 1,
    FdwImportSchemaLimitTo = 2,
    FdwImportSchemaExcept = 3,
}
impl ImportForeignSchemaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED",
            Self::FdwImportSchemaAll => "FDW_IMPORT_SCHEMA_ALL",
            Self::FdwImportSchemaLimitTo => "FDW_IMPORT_SCHEMA_LIMIT_TO",
            Self::FdwImportSchemaExcept => "FDW_IMPORT_SCHEMA_EXCEPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED" => Some(Self::Undefined),
            "FDW_IMPORT_SCHEMA_ALL" => Some(Self::FdwImportSchemaAll),
            "FDW_IMPORT_SCHEMA_LIMIT_TO" => Some(Self::FdwImportSchemaLimitTo),
            "FDW_IMPORT_SCHEMA_EXCEPT" => Some(Self::FdwImportSchemaExcept),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoleStmtType {
    Undefined = 0,
    RolestmtRole = 1,
    RolestmtUser = 2,
    RolestmtGroup = 3,
}
impl RoleStmtType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ROLE_STMT_TYPE_UNDEFINED",
            Self::RolestmtRole => "ROLESTMT_ROLE",
            Self::RolestmtUser => "ROLESTMT_USER",
            Self::RolestmtGroup => "ROLESTMT_GROUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLE_STMT_TYPE_UNDEFINED" => Some(Self::Undefined),
            "ROLESTMT_ROLE" => Some(Self::RolestmtRole),
            "ROLESTMT_USER" => Some(Self::RolestmtUser),
            "ROLESTMT_GROUP" => Some(Self::RolestmtGroup),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FetchDirection {
    Undefined = 0,
    FetchForward = 1,
    FetchBackward = 2,
    FetchAbsolute = 3,
    FetchRelative = 4,
}
impl FetchDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "FETCH_DIRECTION_UNDEFINED",
            Self::FetchForward => "FETCH_FORWARD",
            Self::FetchBackward => "FETCH_BACKWARD",
            Self::FetchAbsolute => "FETCH_ABSOLUTE",
            Self::FetchRelative => "FETCH_RELATIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FETCH_DIRECTION_UNDEFINED" => Some(Self::Undefined),
            "FETCH_FORWARD" => Some(Self::FetchForward),
            "FETCH_BACKWARD" => Some(Self::FetchBackward),
            "FETCH_ABSOLUTE" => Some(Self::FetchAbsolute),
            "FETCH_RELATIVE" => Some(Self::FetchRelative),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionParameterMode {
    Undefined = 0,
    FuncParamIn = 1,
    FuncParamOut = 2,
    FuncParamInout = 3,
    FuncParamVariadic = 4,
    FuncParamTable = 5,
    FuncParamDefault = 6,
}
impl FunctionParameterMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "FUNCTION_PARAMETER_MODE_UNDEFINED",
            Self::FuncParamIn => "FUNC_PARAM_IN",
            Self::FuncParamOut => "FUNC_PARAM_OUT",
            Self::FuncParamInout => "FUNC_PARAM_INOUT",
            Self::FuncParamVariadic => "FUNC_PARAM_VARIADIC",
            Self::FuncParamTable => "FUNC_PARAM_TABLE",
            Self::FuncParamDefault => "FUNC_PARAM_DEFAULT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FUNCTION_PARAMETER_MODE_UNDEFINED" => Some(Self::Undefined),
            "FUNC_PARAM_IN" => Some(Self::FuncParamIn),
            "FUNC_PARAM_OUT" => Some(Self::FuncParamOut),
            "FUNC_PARAM_INOUT" => Some(Self::FuncParamInout),
            "FUNC_PARAM_VARIADIC" => Some(Self::FuncParamVariadic),
            "FUNC_PARAM_TABLE" => Some(Self::FuncParamTable),
            "FUNC_PARAM_DEFAULT" => Some(Self::FuncParamDefault),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStmtKind {
    Undefined = 0,
    TransStmtBegin = 1,
    TransStmtStart = 2,
    TransStmtCommit = 3,
    TransStmtRollback = 4,
    TransStmtSavepoint = 5,
    TransStmtRelease = 6,
    TransStmtRollbackTo = 7,
    TransStmtPrepare = 8,
    TransStmtCommitPrepared = 9,
    TransStmtRollbackPrepared = 10,
}
impl TransactionStmtKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "TRANSACTION_STMT_KIND_UNDEFINED",
            Self::TransStmtBegin => "TRANS_STMT_BEGIN",
            Self::TransStmtStart => "TRANS_STMT_START",
            Self::TransStmtCommit => "TRANS_STMT_COMMIT",
            Self::TransStmtRollback => "TRANS_STMT_ROLLBACK",
            Self::TransStmtSavepoint => "TRANS_STMT_SAVEPOINT",
            Self::TransStmtRelease => "TRANS_STMT_RELEASE",
            Self::TransStmtRollbackTo => "TRANS_STMT_ROLLBACK_TO",
            Self::TransStmtPrepare => "TRANS_STMT_PREPARE",
            Self::TransStmtCommitPrepared => "TRANS_STMT_COMMIT_PREPARED",
            Self::TransStmtRollbackPrepared => "TRANS_STMT_ROLLBACK_PREPARED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STMT_KIND_UNDEFINED" => Some(Self::Undefined),
            "TRANS_STMT_BEGIN" => Some(Self::TransStmtBegin),
            "TRANS_STMT_START" => Some(Self::TransStmtStart),
            "TRANS_STMT_COMMIT" => Some(Self::TransStmtCommit),
            "TRANS_STMT_ROLLBACK" => Some(Self::TransStmtRollback),
            "TRANS_STMT_SAVEPOINT" => Some(Self::TransStmtSavepoint),
            "TRANS_STMT_RELEASE" => Some(Self::TransStmtRelease),
            "TRANS_STMT_ROLLBACK_TO" => Some(Self::TransStmtRollbackTo),
            "TRANS_STMT_PREPARE" => Some(Self::TransStmtPrepare),
            "TRANS_STMT_COMMIT_PREPARED" => Some(Self::TransStmtCommitPrepared),
            "TRANS_STMT_ROLLBACK_PREPARED" => Some(Self::TransStmtRollbackPrepared),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViewCheckOption {
    Undefined = 0,
    NoCheckOption = 1,
    LocalCheckOption = 2,
    CascadedCheckOption = 3,
}
impl ViewCheckOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "VIEW_CHECK_OPTION_UNDEFINED",
            Self::NoCheckOption => "NO_CHECK_OPTION",
            Self::LocalCheckOption => "LOCAL_CHECK_OPTION",
            Self::CascadedCheckOption => "CASCADED_CHECK_OPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIEW_CHECK_OPTION_UNDEFINED" => Some(Self::Undefined),
            "NO_CHECK_OPTION" => Some(Self::NoCheckOption),
            "LOCAL_CHECK_OPTION" => Some(Self::LocalCheckOption),
            "CASCADED_CHECK_OPTION" => Some(Self::CascadedCheckOption),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DiscardMode {
    Undefined = 0,
    DiscardAll = 1,
    DiscardPlans = 2,
    DiscardSequences = 3,
    DiscardTemp = 4,
}
impl DiscardMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "DISCARD_MODE_UNDEFINED",
            Self::DiscardAll => "DISCARD_ALL",
            Self::DiscardPlans => "DISCARD_PLANS",
            Self::DiscardSequences => "DISCARD_SEQUENCES",
            Self::DiscardTemp => "DISCARD_TEMP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISCARD_MODE_UNDEFINED" => Some(Self::Undefined),
            "DISCARD_ALL" => Some(Self::DiscardAll),
            "DISCARD_PLANS" => Some(Self::DiscardPlans),
            "DISCARD_SEQUENCES" => Some(Self::DiscardSequences),
            "DISCARD_TEMP" => Some(Self::DiscardTemp),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReindexObjectType {
    Undefined = 0,
    ReindexObjectIndex = 1,
    ReindexObjectTable = 2,
    ReindexObjectSchema = 3,
    ReindexObjectSystem = 4,
    ReindexObjectDatabase = 5,
}
impl ReindexObjectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "REINDEX_OBJECT_TYPE_UNDEFINED",
            Self::ReindexObjectIndex => "REINDEX_OBJECT_INDEX",
            Self::ReindexObjectTable => "REINDEX_OBJECT_TABLE",
            Self::ReindexObjectSchema => "REINDEX_OBJECT_SCHEMA",
            Self::ReindexObjectSystem => "REINDEX_OBJECT_SYSTEM",
            Self::ReindexObjectDatabase => "REINDEX_OBJECT_DATABASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REINDEX_OBJECT_TYPE_UNDEFINED" => Some(Self::Undefined),
            "REINDEX_OBJECT_INDEX" => Some(Self::ReindexObjectIndex),
            "REINDEX_OBJECT_TABLE" => Some(Self::ReindexObjectTable),
            "REINDEX_OBJECT_SCHEMA" => Some(Self::ReindexObjectSchema),
            "REINDEX_OBJECT_SYSTEM" => Some(Self::ReindexObjectSystem),
            "REINDEX_OBJECT_DATABASE" => Some(Self::ReindexObjectDatabase),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlterTsConfigType {
    AlterTsconfigTypeUndefined = 0,
    AlterTsconfigAddMapping = 1,
    AlterTsconfigAlterMappingForToken = 2,
    AlterTsconfigReplaceDict = 3,
    AlterTsconfigReplaceDictForToken = 4,
    AlterTsconfigDropMapping = 5,
}
impl AlterTsConfigType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AlterTsconfigTypeUndefined => "ALTER_TSCONFIG_TYPE_UNDEFINED",
            Self::AlterTsconfigAddMapping => "ALTER_TSCONFIG_ADD_MAPPING",
            Self::AlterTsconfigAlterMappingForToken => {
                "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN"
            }
            Self::AlterTsconfigReplaceDict => "ALTER_TSCONFIG_REPLACE_DICT",
            Self::AlterTsconfigReplaceDictForToken => {
                "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN"
            }
            Self::AlterTsconfigDropMapping => "ALTER_TSCONFIG_DROP_MAPPING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALTER_TSCONFIG_TYPE_UNDEFINED" => Some(Self::AlterTsconfigTypeUndefined),
            "ALTER_TSCONFIG_ADD_MAPPING" => Some(Self::AlterTsconfigAddMapping),
            "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN" => {
                Some(Self::AlterTsconfigAlterMappingForToken)
            }
            "ALTER_TSCONFIG_REPLACE_DICT" => Some(Self::AlterTsconfigReplaceDict),
            "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN" => {
                Some(Self::AlterTsconfigReplaceDictForToken)
            }
            "ALTER_TSCONFIG_DROP_MAPPING" => Some(Self::AlterTsconfigDropMapping),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PublicationObjSpecType {
    Undefined = 0,
    PublicationobjTable = 1,
    PublicationobjTablesInSchema = 2,
    PublicationobjTablesInCurSchema = 3,
    PublicationobjContinuation = 4,
}
impl PublicationObjSpecType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED",
            Self::PublicationobjTable => "PUBLICATIONOBJ_TABLE",
            Self::PublicationobjTablesInSchema => "PUBLICATIONOBJ_TABLES_IN_SCHEMA",
            Self::PublicationobjTablesInCurSchema => {
                "PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA"
            }
            Self::PublicationobjContinuation => "PUBLICATIONOBJ_CONTINUATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED" => Some(Self::Undefined),
            "PUBLICATIONOBJ_TABLE" => Some(Self::PublicationobjTable),
            "PUBLICATIONOBJ_TABLES_IN_SCHEMA" => Some(Self::PublicationobjTablesInSchema),
            "PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA" => {
                Some(Self::PublicationobjTablesInCurSchema)
            }
            "PUBLICATIONOBJ_CONTINUATION" => Some(Self::PublicationobjContinuation),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlterPublicationAction {
    Undefined = 0,
    ApAddObjects = 1,
    ApDropObjects = 2,
    ApSetObjects = 3,
}
impl AlterPublicationAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ALTER_PUBLICATION_ACTION_UNDEFINED",
            Self::ApAddObjects => "AP_AddObjects",
            Self::ApDropObjects => "AP_DropObjects",
            Self::ApSetObjects => "AP_SetObjects",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALTER_PUBLICATION_ACTION_UNDEFINED" => Some(Self::Undefined),
            "AP_AddObjects" => Some(Self::ApAddObjects),
            "AP_DropObjects" => Some(Self::ApDropObjects),
            "AP_SetObjects" => Some(Self::ApSetObjects),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlterSubscriptionType {
    Undefined = 0,
    AlterSubscriptionOptions = 1,
    AlterSubscriptionConnection = 2,
    AlterSubscriptionSetPublication = 3,
    AlterSubscriptionAddPublication = 4,
    AlterSubscriptionDropPublication = 5,
    AlterSubscriptionRefresh = 6,
    AlterSubscriptionEnabled = 7,
    AlterSubscriptionSkip = 8,
}
impl AlterSubscriptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ALTER_SUBSCRIPTION_TYPE_UNDEFINED",
            Self::AlterSubscriptionOptions => "ALTER_SUBSCRIPTION_OPTIONS",
            Self::AlterSubscriptionConnection => "ALTER_SUBSCRIPTION_CONNECTION",
            Self::AlterSubscriptionSetPublication => "ALTER_SUBSCRIPTION_SET_PUBLICATION",
            Self::AlterSubscriptionAddPublication => "ALTER_SUBSCRIPTION_ADD_PUBLICATION",
            Self::AlterSubscriptionDropPublication => {
                "ALTER_SUBSCRIPTION_DROP_PUBLICATION"
            }
            Self::AlterSubscriptionRefresh => "ALTER_SUBSCRIPTION_REFRESH",
            Self::AlterSubscriptionEnabled => "ALTER_SUBSCRIPTION_ENABLED",
            Self::AlterSubscriptionSkip => "ALTER_SUBSCRIPTION_SKIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALTER_SUBSCRIPTION_TYPE_UNDEFINED" => Some(Self::Undefined),
            "ALTER_SUBSCRIPTION_OPTIONS" => Some(Self::AlterSubscriptionOptions),
            "ALTER_SUBSCRIPTION_CONNECTION" => Some(Self::AlterSubscriptionConnection),
            "ALTER_SUBSCRIPTION_SET_PUBLICATION" => {
                Some(Self::AlterSubscriptionSetPublication)
            }
            "ALTER_SUBSCRIPTION_ADD_PUBLICATION" => {
                Some(Self::AlterSubscriptionAddPublication)
            }
            "ALTER_SUBSCRIPTION_DROP_PUBLICATION" => {
                Some(Self::AlterSubscriptionDropPublication)
            }
            "ALTER_SUBSCRIPTION_REFRESH" => Some(Self::AlterSubscriptionRefresh),
            "ALTER_SUBSCRIPTION_ENABLED" => Some(Self::AlterSubscriptionEnabled),
            "ALTER_SUBSCRIPTION_SKIP" => Some(Self::AlterSubscriptionSkip),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OverridingKind {
    Undefined = 0,
    OverridingNotSet = 1,
    OverridingUserValue = 2,
    OverridingSystemValue = 3,
}
impl OverridingKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "OVERRIDING_KIND_UNDEFINED",
            Self::OverridingNotSet => "OVERRIDING_NOT_SET",
            Self::OverridingUserValue => "OVERRIDING_USER_VALUE",
            Self::OverridingSystemValue => "OVERRIDING_SYSTEM_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OVERRIDING_KIND_UNDEFINED" => Some(Self::Undefined),
            "OVERRIDING_NOT_SET" => Some(Self::OverridingNotSet),
            "OVERRIDING_USER_VALUE" => Some(Self::OverridingUserValue),
            "OVERRIDING_SYSTEM_VALUE" => Some(Self::OverridingSystemValue),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OnCommitAction {
    Undefined = 0,
    OncommitNoop = 1,
    OncommitPreserveRows = 2,
    OncommitDeleteRows = 3,
    OncommitDrop = 4,
}
impl OnCommitAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ON_COMMIT_ACTION_UNDEFINED",
            Self::OncommitNoop => "ONCOMMIT_NOOP",
            Self::OncommitPreserveRows => "ONCOMMIT_PRESERVE_ROWS",
            Self::OncommitDeleteRows => "ONCOMMIT_DELETE_ROWS",
            Self::OncommitDrop => "ONCOMMIT_DROP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ON_COMMIT_ACTION_UNDEFINED" => Some(Self::Undefined),
            "ONCOMMIT_NOOP" => Some(Self::OncommitNoop),
            "ONCOMMIT_PRESERVE_ROWS" => Some(Self::OncommitPreserveRows),
            "ONCOMMIT_DELETE_ROWS" => Some(Self::OncommitDeleteRows),
            "ONCOMMIT_DROP" => Some(Self::OncommitDrop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TableFuncType {
    Undefined = 0,
    TftXmltable = 1,
    TftJsonTable = 2,
}
impl TableFuncType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "TABLE_FUNC_TYPE_UNDEFINED",
            Self::TftXmltable => "TFT_XMLTABLE",
            Self::TftJsonTable => "TFT_JSON_TABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLE_FUNC_TYPE_UNDEFINED" => Some(Self::Undefined),
            "TFT_XMLTABLE" => Some(Self::TftXmltable),
            "TFT_JSON_TABLE" => Some(Self::TftJsonTable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParamKind {
    Undefined = 0,
    ParamExtern = 1,
    ParamExec = 2,
    ParamSublink = 3,
    ParamMultiexpr = 4,
}
impl ParamKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "PARAM_KIND_UNDEFINED",
            Self::ParamExtern => "PARAM_EXTERN",
            Self::ParamExec => "PARAM_EXEC",
            Self::ParamSublink => "PARAM_SUBLINK",
            Self::ParamMultiexpr => "PARAM_MULTIEXPR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARAM_KIND_UNDEFINED" => Some(Self::Undefined),
            "PARAM_EXTERN" => Some(Self::ParamExtern),
            "PARAM_EXEC" => Some(Self::ParamExec),
            "PARAM_SUBLINK" => Some(Self::ParamSublink),
            "PARAM_MULTIEXPR" => Some(Self::ParamMultiexpr),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoercionContext {
    Undefined = 0,
    CoercionImplicit = 1,
    CoercionAssignment = 2,
    CoercionPlpgsql = 3,
    CoercionExplicit = 4,
}
impl CoercionContext {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "COERCION_CONTEXT_UNDEFINED",
            Self::CoercionImplicit => "COERCION_IMPLICIT",
            Self::CoercionAssignment => "COERCION_ASSIGNMENT",
            Self::CoercionPlpgsql => "COERCION_PLPGSQL",
            Self::CoercionExplicit => "COERCION_EXPLICIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COERCION_CONTEXT_UNDEFINED" => Some(Self::Undefined),
            "COERCION_IMPLICIT" => Some(Self::CoercionImplicit),
            "COERCION_ASSIGNMENT" => Some(Self::CoercionAssignment),
            "COERCION_PLPGSQL" => Some(Self::CoercionPlpgsql),
            "COERCION_EXPLICIT" => Some(Self::CoercionExplicit),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoercionForm {
    Undefined = 0,
    CoerceExplicitCall = 1,
    CoerceExplicitCast = 2,
    CoerceImplicitCast = 3,
    CoerceSqlSyntax = 4,
}
impl CoercionForm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "COERCION_FORM_UNDEFINED",
            Self::CoerceExplicitCall => "COERCE_EXPLICIT_CALL",
            Self::CoerceExplicitCast => "COERCE_EXPLICIT_CAST",
            Self::CoerceImplicitCast => "COERCE_IMPLICIT_CAST",
            Self::CoerceSqlSyntax => "COERCE_SQL_SYNTAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COERCION_FORM_UNDEFINED" => Some(Self::Undefined),
            "COERCE_EXPLICIT_CALL" => Some(Self::CoerceExplicitCall),
            "COERCE_EXPLICIT_CAST" => Some(Self::CoerceExplicitCast),
            "COERCE_IMPLICIT_CAST" => Some(Self::CoerceImplicitCast),
            "COERCE_SQL_SYNTAX" => Some(Self::CoerceSqlSyntax),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoolExprType {
    Undefined = 0,
    AndExpr = 1,
    OrExpr = 2,
    NotExpr = 3,
}
impl BoolExprType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "BOOL_EXPR_TYPE_UNDEFINED",
            Self::AndExpr => "AND_EXPR",
            Self::OrExpr => "OR_EXPR",
            Self::NotExpr => "NOT_EXPR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOOL_EXPR_TYPE_UNDEFINED" => Some(Self::Undefined),
            "AND_EXPR" => Some(Self::AndExpr),
            "OR_EXPR" => Some(Self::OrExpr),
            "NOT_EXPR" => Some(Self::NotExpr),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubLinkType {
    Undefined = 0,
    ExistsSublink = 1,
    AllSublink = 2,
    AnySublink = 3,
    RowcompareSublink = 4,
    ExprSublink = 5,
    MultiexprSublink = 6,
    ArraySublink = 7,
    CteSublink = 8,
}
impl SubLinkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SUB_LINK_TYPE_UNDEFINED",
            Self::ExistsSublink => "EXISTS_SUBLINK",
            Self::AllSublink => "ALL_SUBLINK",
            Self::AnySublink => "ANY_SUBLINK",
            Self::RowcompareSublink => "ROWCOMPARE_SUBLINK",
            Self::ExprSublink => "EXPR_SUBLINK",
            Self::MultiexprSublink => "MULTIEXPR_SUBLINK",
            Self::ArraySublink => "ARRAY_SUBLINK",
            Self::CteSublink => "CTE_SUBLINK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUB_LINK_TYPE_UNDEFINED" => Some(Self::Undefined),
            "EXISTS_SUBLINK" => Some(Self::ExistsSublink),
            "ALL_SUBLINK" => Some(Self::AllSublink),
            "ANY_SUBLINK" => Some(Self::AnySublink),
            "ROWCOMPARE_SUBLINK" => Some(Self::RowcompareSublink),
            "EXPR_SUBLINK" => Some(Self::ExprSublink),
            "MULTIEXPR_SUBLINK" => Some(Self::MultiexprSublink),
            "ARRAY_SUBLINK" => Some(Self::ArraySublink),
            "CTE_SUBLINK" => Some(Self::CteSublink),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RowCompareType {
    Undefined = 0,
    RowcompareLt = 1,
    RowcompareLe = 2,
    RowcompareEq = 3,
    RowcompareGe = 4,
    RowcompareGt = 5,
    RowcompareNe = 6,
}
impl RowCompareType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ROW_COMPARE_TYPE_UNDEFINED",
            Self::RowcompareLt => "ROWCOMPARE_LT",
            Self::RowcompareLe => "ROWCOMPARE_LE",
            Self::RowcompareEq => "ROWCOMPARE_EQ",
            Self::RowcompareGe => "ROWCOMPARE_GE",
            Self::RowcompareGt => "ROWCOMPARE_GT",
            Self::RowcompareNe => "ROWCOMPARE_NE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROW_COMPARE_TYPE_UNDEFINED" => Some(Self::Undefined),
            "ROWCOMPARE_LT" => Some(Self::RowcompareLt),
            "ROWCOMPARE_LE" => Some(Self::RowcompareLe),
            "ROWCOMPARE_EQ" => Some(Self::RowcompareEq),
            "ROWCOMPARE_GE" => Some(Self::RowcompareGe),
            "ROWCOMPARE_GT" => Some(Self::RowcompareGt),
            "ROWCOMPARE_NE" => Some(Self::RowcompareNe),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MinMaxOp {
    Undefined = 0,
    IsGreatest = 1,
    IsLeast = 2,
}
impl MinMaxOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "MIN_MAX_OP_UNDEFINED",
            Self::IsGreatest => "IS_GREATEST",
            Self::IsLeast => "IS_LEAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MIN_MAX_OP_UNDEFINED" => Some(Self::Undefined),
            "IS_GREATEST" => Some(Self::IsGreatest),
            "IS_LEAST" => Some(Self::IsLeast),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlValueFunctionOp {
    SqlvalueFunctionOpUndefined = 0,
    SvfopCurrentDate = 1,
    SvfopCurrentTime = 2,
    SvfopCurrentTimeN = 3,
    SvfopCurrentTimestamp = 4,
    SvfopCurrentTimestampN = 5,
    SvfopLocaltime = 6,
    SvfopLocaltimeN = 7,
    SvfopLocaltimestamp = 8,
    SvfopLocaltimestampN = 9,
    SvfopCurrentRole = 10,
    SvfopCurrentUser = 11,
    SvfopUser = 12,
    SvfopSessionUser = 13,
    SvfopCurrentCatalog = 14,
    SvfopCurrentSchema = 15,
}
impl SqlValueFunctionOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SqlvalueFunctionOpUndefined => "SQLVALUE_FUNCTION_OP_UNDEFINED",
            Self::SvfopCurrentDate => "SVFOP_CURRENT_DATE",
            Self::SvfopCurrentTime => "SVFOP_CURRENT_TIME",
            Self::SvfopCurrentTimeN => "SVFOP_CURRENT_TIME_N",
            Self::SvfopCurrentTimestamp => "SVFOP_CURRENT_TIMESTAMP",
            Self::SvfopCurrentTimestampN => "SVFOP_CURRENT_TIMESTAMP_N",
            Self::SvfopLocaltime => "SVFOP_LOCALTIME",
            Self::SvfopLocaltimeN => "SVFOP_LOCALTIME_N",
            Self::SvfopLocaltimestamp => "SVFOP_LOCALTIMESTAMP",
            Self::SvfopLocaltimestampN => "SVFOP_LOCALTIMESTAMP_N",
            Self::SvfopCurrentRole => "SVFOP_CURRENT_ROLE",
            Self::SvfopCurrentUser => "SVFOP_CURRENT_USER",
            Self::SvfopUser => "SVFOP_USER",
            Self::SvfopSessionUser => "SVFOP_SESSION_USER",
            Self::SvfopCurrentCatalog => "SVFOP_CURRENT_CATALOG",
            Self::SvfopCurrentSchema => "SVFOP_CURRENT_SCHEMA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQLVALUE_FUNCTION_OP_UNDEFINED" => Some(Self::SqlvalueFunctionOpUndefined),
            "SVFOP_CURRENT_DATE" => Some(Self::SvfopCurrentDate),
            "SVFOP_CURRENT_TIME" => Some(Self::SvfopCurrentTime),
            "SVFOP_CURRENT_TIME_N" => Some(Self::SvfopCurrentTimeN),
            "SVFOP_CURRENT_TIMESTAMP" => Some(Self::SvfopCurrentTimestamp),
            "SVFOP_CURRENT_TIMESTAMP_N" => Some(Self::SvfopCurrentTimestampN),
            "SVFOP_LOCALTIME" => Some(Self::SvfopLocaltime),
            "SVFOP_LOCALTIME_N" => Some(Self::SvfopLocaltimeN),
            "SVFOP_LOCALTIMESTAMP" => Some(Self::SvfopLocaltimestamp),
            "SVFOP_LOCALTIMESTAMP_N" => Some(Self::SvfopLocaltimestampN),
            "SVFOP_CURRENT_ROLE" => Some(Self::SvfopCurrentRole),
            "SVFOP_CURRENT_USER" => Some(Self::SvfopCurrentUser),
            "SVFOP_USER" => Some(Self::SvfopUser),
            "SVFOP_SESSION_USER" => Some(Self::SvfopSessionUser),
            "SVFOP_CURRENT_CATALOG" => Some(Self::SvfopCurrentCatalog),
            "SVFOP_CURRENT_SCHEMA" => Some(Self::SvfopCurrentSchema),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum XmlExprOp {
    Undefined = 0,
    IsXmlconcat = 1,
    IsXmlelement = 2,
    IsXmlforest = 3,
    IsXmlparse = 4,
    IsXmlpi = 5,
    IsXmlroot = 6,
    IsXmlserialize = 7,
    IsDocument = 8,
}
impl XmlExprOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "XML_EXPR_OP_UNDEFINED",
            Self::IsXmlconcat => "IS_XMLCONCAT",
            Self::IsXmlelement => "IS_XMLELEMENT",
            Self::IsXmlforest => "IS_XMLFOREST",
            Self::IsXmlparse => "IS_XMLPARSE",
            Self::IsXmlpi => "IS_XMLPI",
            Self::IsXmlroot => "IS_XMLROOT",
            Self::IsXmlserialize => "IS_XMLSERIALIZE",
            Self::IsDocument => "IS_DOCUMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "XML_EXPR_OP_UNDEFINED" => Some(Self::Undefined),
            "IS_XMLCONCAT" => Some(Self::IsXmlconcat),
            "IS_XMLELEMENT" => Some(Self::IsXmlelement),
            "IS_XMLFOREST" => Some(Self::IsXmlforest),
            "IS_XMLPARSE" => Some(Self::IsXmlparse),
            "IS_XMLPI" => Some(Self::IsXmlpi),
            "IS_XMLROOT" => Some(Self::IsXmlroot),
            "IS_XMLSERIALIZE" => Some(Self::IsXmlserialize),
            "IS_DOCUMENT" => Some(Self::IsDocument),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum XmlOptionType {
    Undefined = 0,
    XmloptionDocument = 1,
    XmloptionContent = 2,
}
impl XmlOptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "XML_OPTION_TYPE_UNDEFINED",
            Self::XmloptionDocument => "XMLOPTION_DOCUMENT",
            Self::XmloptionContent => "XMLOPTION_CONTENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "XML_OPTION_TYPE_UNDEFINED" => Some(Self::Undefined),
            "XMLOPTION_DOCUMENT" => Some(Self::XmloptionDocument),
            "XMLOPTION_CONTENT" => Some(Self::XmloptionContent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonEncoding {
    Undefined = 0,
    JsEncDefault = 1,
    JsEncUtf8 = 2,
    JsEncUtf16 = 3,
    JsEncUtf32 = 4,
}
impl JsonEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_ENCODING_UNDEFINED",
            Self::JsEncDefault => "JS_ENC_DEFAULT",
            Self::JsEncUtf8 => "JS_ENC_UTF8",
            Self::JsEncUtf16 => "JS_ENC_UTF16",
            Self::JsEncUtf32 => "JS_ENC_UTF32",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_ENCODING_UNDEFINED" => Some(Self::Undefined),
            "JS_ENC_DEFAULT" => Some(Self::JsEncDefault),
            "JS_ENC_UTF8" => Some(Self::JsEncUtf8),
            "JS_ENC_UTF16" => Some(Self::JsEncUtf16),
            "JS_ENC_UTF32" => Some(Self::JsEncUtf32),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonFormatType {
    Undefined = 0,
    JsFormatDefault = 1,
    JsFormatJson = 2,
    JsFormatJsonb = 3,
}
impl JsonFormatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_FORMAT_TYPE_UNDEFINED",
            Self::JsFormatDefault => "JS_FORMAT_DEFAULT",
            Self::JsFormatJson => "JS_FORMAT_JSON",
            Self::JsFormatJsonb => "JS_FORMAT_JSONB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_FORMAT_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JS_FORMAT_DEFAULT" => Some(Self::JsFormatDefault),
            "JS_FORMAT_JSON" => Some(Self::JsFormatJson),
            "JS_FORMAT_JSONB" => Some(Self::JsFormatJsonb),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonConstructorType {
    Undefined = 0,
    JsctorJsonObject = 1,
    JsctorJsonArray = 2,
    JsctorJsonObjectagg = 3,
    JsctorJsonArrayagg = 4,
    JsctorJsonParse = 5,
    JsctorJsonScalar = 6,
    JsctorJsonSerialize = 7,
}
impl JsonConstructorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_CONSTRUCTOR_TYPE_UNDEFINED",
            Self::JsctorJsonObject => "JSCTOR_JSON_OBJECT",
            Self::JsctorJsonArray => "JSCTOR_JSON_ARRAY",
            Self::JsctorJsonObjectagg => "JSCTOR_JSON_OBJECTAGG",
            Self::JsctorJsonArrayagg => "JSCTOR_JSON_ARRAYAGG",
            Self::JsctorJsonParse => "JSCTOR_JSON_PARSE",
            Self::JsctorJsonScalar => "JSCTOR_JSON_SCALAR",
            Self::JsctorJsonSerialize => "JSCTOR_JSON_SERIALIZE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_CONSTRUCTOR_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JSCTOR_JSON_OBJECT" => Some(Self::JsctorJsonObject),
            "JSCTOR_JSON_ARRAY" => Some(Self::JsctorJsonArray),
            "JSCTOR_JSON_OBJECTAGG" => Some(Self::JsctorJsonObjectagg),
            "JSCTOR_JSON_ARRAYAGG" => Some(Self::JsctorJsonArrayagg),
            "JSCTOR_JSON_PARSE" => Some(Self::JsctorJsonParse),
            "JSCTOR_JSON_SCALAR" => Some(Self::JsctorJsonScalar),
            "JSCTOR_JSON_SERIALIZE" => Some(Self::JsctorJsonSerialize),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonValueType {
    Undefined = 0,
    JsTypeAny = 1,
    JsTypeObject = 2,
    JsTypeArray = 3,
    JsTypeScalar = 4,
}
impl JsonValueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_VALUE_TYPE_UNDEFINED",
            Self::JsTypeAny => "JS_TYPE_ANY",
            Self::JsTypeObject => "JS_TYPE_OBJECT",
            Self::JsTypeArray => "JS_TYPE_ARRAY",
            Self::JsTypeScalar => "JS_TYPE_SCALAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_VALUE_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JS_TYPE_ANY" => Some(Self::JsTypeAny),
            "JS_TYPE_OBJECT" => Some(Self::JsTypeObject),
            "JS_TYPE_ARRAY" => Some(Self::JsTypeArray),
            "JS_TYPE_SCALAR" => Some(Self::JsTypeScalar),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonWrapper {
    Undefined = 0,
    JswUnspec = 1,
    JswNone = 2,
    JswConditional = 3,
    JswUnconditional = 4,
}
impl JsonWrapper {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_WRAPPER_UNDEFINED",
            Self::JswUnspec => "JSW_UNSPEC",
            Self::JswNone => "JSW_NONE",
            Self::JswConditional => "JSW_CONDITIONAL",
            Self::JswUnconditional => "JSW_UNCONDITIONAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_WRAPPER_UNDEFINED" => Some(Self::Undefined),
            "JSW_UNSPEC" => Some(Self::JswUnspec),
            "JSW_NONE" => Some(Self::JswNone),
            "JSW_CONDITIONAL" => Some(Self::JswConditional),
            "JSW_UNCONDITIONAL" => Some(Self::JswUnconditional),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonBehaviorType {
    Undefined = 0,
    JsonBehaviorNull = 1,
    JsonBehaviorError = 2,
    JsonBehaviorEmpty = 3,
    JsonBehaviorTrue = 4,
    JsonBehaviorFalse = 5,
    JsonBehaviorUnknown = 6,
    JsonBehaviorEmptyArray = 7,
    JsonBehaviorEmptyObject = 8,
    JsonBehaviorDefault = 9,
}
impl JsonBehaviorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_BEHAVIOR_TYPE_UNDEFINED",
            Self::JsonBehaviorNull => "JSON_BEHAVIOR_NULL",
            Self::JsonBehaviorError => "JSON_BEHAVIOR_ERROR",
            Self::JsonBehaviorEmpty => "JSON_BEHAVIOR_EMPTY",
            Self::JsonBehaviorTrue => "JSON_BEHAVIOR_TRUE",
            Self::JsonBehaviorFalse => "JSON_BEHAVIOR_FALSE",
            Self::JsonBehaviorUnknown => "JSON_BEHAVIOR_UNKNOWN",
            Self::JsonBehaviorEmptyArray => "JSON_BEHAVIOR_EMPTY_ARRAY",
            Self::JsonBehaviorEmptyObject => "JSON_BEHAVIOR_EMPTY_OBJECT",
            Self::JsonBehaviorDefault => "JSON_BEHAVIOR_DEFAULT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_BEHAVIOR_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JSON_BEHAVIOR_NULL" => Some(Self::JsonBehaviorNull),
            "JSON_BEHAVIOR_ERROR" => Some(Self::JsonBehaviorError),
            "JSON_BEHAVIOR_EMPTY" => Some(Self::JsonBehaviorEmpty),
            "JSON_BEHAVIOR_TRUE" => Some(Self::JsonBehaviorTrue),
            "JSON_BEHAVIOR_FALSE" => Some(Self::JsonBehaviorFalse),
            "JSON_BEHAVIOR_UNKNOWN" => Some(Self::JsonBehaviorUnknown),
            "JSON_BEHAVIOR_EMPTY_ARRAY" => Some(Self::JsonBehaviorEmptyArray),
            "JSON_BEHAVIOR_EMPTY_OBJECT" => Some(Self::JsonBehaviorEmptyObject),
            "JSON_BEHAVIOR_DEFAULT" => Some(Self::JsonBehaviorDefault),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonExprOp {
    Undefined = 0,
    JsonExistsOp = 1,
    JsonQueryOp = 2,
    JsonValueOp = 3,
    JsonTableOp = 4,
}
impl JsonExprOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JSON_EXPR_OP_UNDEFINED",
            Self::JsonExistsOp => "JSON_EXISTS_OP",
            Self::JsonQueryOp => "JSON_QUERY_OP",
            Self::JsonValueOp => "JSON_VALUE_OP",
            Self::JsonTableOp => "JSON_TABLE_OP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_EXPR_OP_UNDEFINED" => Some(Self::Undefined),
            "JSON_EXISTS_OP" => Some(Self::JsonExistsOp),
            "JSON_QUERY_OP" => Some(Self::JsonQueryOp),
            "JSON_VALUE_OP" => Some(Self::JsonValueOp),
            "JSON_TABLE_OP" => Some(Self::JsonTableOp),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NullTestType {
    Undefined = 0,
    IsNull = 1,
    IsNotNull = 2,
}
impl NullTestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "NULL_TEST_TYPE_UNDEFINED",
            Self::IsNull => "IS_NULL",
            Self::IsNotNull => "IS_NOT_NULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NULL_TEST_TYPE_UNDEFINED" => Some(Self::Undefined),
            "IS_NULL" => Some(Self::IsNull),
            "IS_NOT_NULL" => Some(Self::IsNotNull),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoolTestType {
    Undefined = 0,
    IsTrue = 1,
    IsNotTrue = 2,
    IsFalse = 3,
    IsNotFalse = 4,
    IsUnknown = 5,
    IsNotUnknown = 6,
}
impl BoolTestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "BOOL_TEST_TYPE_UNDEFINED",
            Self::IsTrue => "IS_TRUE",
            Self::IsNotTrue => "IS_NOT_TRUE",
            Self::IsFalse => "IS_FALSE",
            Self::IsNotFalse => "IS_NOT_FALSE",
            Self::IsUnknown => "IS_UNKNOWN",
            Self::IsNotUnknown => "IS_NOT_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOOL_TEST_TYPE_UNDEFINED" => Some(Self::Undefined),
            "IS_TRUE" => Some(Self::IsTrue),
            "IS_NOT_TRUE" => Some(Self::IsNotTrue),
            "IS_FALSE" => Some(Self::IsFalse),
            "IS_NOT_FALSE" => Some(Self::IsNotFalse),
            "IS_UNKNOWN" => Some(Self::IsUnknown),
            "IS_NOT_UNKNOWN" => Some(Self::IsNotUnknown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MergeMatchKind {
    Undefined = 0,
    MergeWhenMatched = 1,
    MergeWhenNotMatchedBySource = 2,
    MergeWhenNotMatchedByTarget = 3,
}
impl MergeMatchKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "MERGE_MATCH_KIND_UNDEFINED",
            Self::MergeWhenMatched => "MERGE_WHEN_MATCHED",
            Self::MergeWhenNotMatchedBySource => "MERGE_WHEN_NOT_MATCHED_BY_SOURCE",
            Self::MergeWhenNotMatchedByTarget => "MERGE_WHEN_NOT_MATCHED_BY_TARGET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MERGE_MATCH_KIND_UNDEFINED" => Some(Self::Undefined),
            "MERGE_WHEN_MATCHED" => Some(Self::MergeWhenMatched),
            "MERGE_WHEN_NOT_MATCHED_BY_SOURCE" => Some(Self::MergeWhenNotMatchedBySource),
            "MERGE_WHEN_NOT_MATCHED_BY_TARGET" => Some(Self::MergeWhenNotMatchedByTarget),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CmdType {
    Undefined = 0,
    CmdUnknown = 1,
    CmdSelect = 2,
    CmdUpdate = 3,
    CmdInsert = 4,
    CmdDelete = 5,
    CmdMerge = 6,
    CmdUtility = 7,
    CmdNothing = 8,
}
impl CmdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "CMD_TYPE_UNDEFINED",
            Self::CmdUnknown => "CMD_UNKNOWN",
            Self::CmdSelect => "CMD_SELECT",
            Self::CmdUpdate => "CMD_UPDATE",
            Self::CmdInsert => "CMD_INSERT",
            Self::CmdDelete => "CMD_DELETE",
            Self::CmdMerge => "CMD_MERGE",
            Self::CmdUtility => "CMD_UTILITY",
            Self::CmdNothing => "CMD_NOTHING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CMD_TYPE_UNDEFINED" => Some(Self::Undefined),
            "CMD_UNKNOWN" => Some(Self::CmdUnknown),
            "CMD_SELECT" => Some(Self::CmdSelect),
            "CMD_UPDATE" => Some(Self::CmdUpdate),
            "CMD_INSERT" => Some(Self::CmdInsert),
            "CMD_DELETE" => Some(Self::CmdDelete),
            "CMD_MERGE" => Some(Self::CmdMerge),
            "CMD_UTILITY" => Some(Self::CmdUtility),
            "CMD_NOTHING" => Some(Self::CmdNothing),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinType {
    Undefined = 0,
    JoinInner = 1,
    JoinLeft = 2,
    JoinFull = 3,
    JoinRight = 4,
    JoinSemi = 5,
    JoinAnti = 6,
    JoinRightAnti = 7,
    JoinUniqueOuter = 8,
    JoinUniqueInner = 9,
}
impl JoinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "JOIN_TYPE_UNDEFINED",
            Self::JoinInner => "JOIN_INNER",
            Self::JoinLeft => "JOIN_LEFT",
            Self::JoinFull => "JOIN_FULL",
            Self::JoinRight => "JOIN_RIGHT",
            Self::JoinSemi => "JOIN_SEMI",
            Self::JoinAnti => "JOIN_ANTI",
            Self::JoinRightAnti => "JOIN_RIGHT_ANTI",
            Self::JoinUniqueOuter => "JOIN_UNIQUE_OUTER",
            Self::JoinUniqueInner => "JOIN_UNIQUE_INNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOIN_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JOIN_INNER" => Some(Self::JoinInner),
            "JOIN_LEFT" => Some(Self::JoinLeft),
            "JOIN_FULL" => Some(Self::JoinFull),
            "JOIN_RIGHT" => Some(Self::JoinRight),
            "JOIN_SEMI" => Some(Self::JoinSemi),
            "JOIN_ANTI" => Some(Self::JoinAnti),
            "JOIN_RIGHT_ANTI" => Some(Self::JoinRightAnti),
            "JOIN_UNIQUE_OUTER" => Some(Self::JoinUniqueOuter),
            "JOIN_UNIQUE_INNER" => Some(Self::JoinUniqueInner),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggStrategy {
    Undefined = 0,
    AggPlain = 1,
    AggSorted = 2,
    AggHashed = 3,
    AggMixed = 4,
}
impl AggStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "AGG_STRATEGY_UNDEFINED",
            Self::AggPlain => "AGG_PLAIN",
            Self::AggSorted => "AGG_SORTED",
            Self::AggHashed => "AGG_HASHED",
            Self::AggMixed => "AGG_MIXED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGG_STRATEGY_UNDEFINED" => Some(Self::Undefined),
            "AGG_PLAIN" => Some(Self::AggPlain),
            "AGG_SORTED" => Some(Self::AggSorted),
            "AGG_HASHED" => Some(Self::AggHashed),
            "AGG_MIXED" => Some(Self::AggMixed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggSplit {
    Undefined = 0,
    AggsplitSimple = 1,
    AggsplitInitialSerial = 2,
    AggsplitFinalDeserial = 3,
}
impl AggSplit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "AGG_SPLIT_UNDEFINED",
            Self::AggsplitSimple => "AGGSPLIT_SIMPLE",
            Self::AggsplitInitialSerial => "AGGSPLIT_INITIAL_SERIAL",
            Self::AggsplitFinalDeserial => "AGGSPLIT_FINAL_DESERIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGG_SPLIT_UNDEFINED" => Some(Self::Undefined),
            "AGGSPLIT_SIMPLE" => Some(Self::AggsplitSimple),
            "AGGSPLIT_INITIAL_SERIAL" => Some(Self::AggsplitInitialSerial),
            "AGGSPLIT_FINAL_DESERIAL" => Some(Self::AggsplitFinalDeserial),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SetOpCmd {
    Undefined = 0,
    SetopcmdIntersect = 1,
    SetopcmdIntersectAll = 2,
    SetopcmdExcept = 3,
    SetopcmdExceptAll = 4,
}
impl SetOpCmd {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SET_OP_CMD_UNDEFINED",
            Self::SetopcmdIntersect => "SETOPCMD_INTERSECT",
            Self::SetopcmdIntersectAll => "SETOPCMD_INTERSECT_ALL",
            Self::SetopcmdExcept => "SETOPCMD_EXCEPT",
            Self::SetopcmdExceptAll => "SETOPCMD_EXCEPT_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SET_OP_CMD_UNDEFINED" => Some(Self::Undefined),
            "SETOPCMD_INTERSECT" => Some(Self::SetopcmdIntersect),
            "SETOPCMD_INTERSECT_ALL" => Some(Self::SetopcmdIntersectAll),
            "SETOPCMD_EXCEPT" => Some(Self::SetopcmdExcept),
            "SETOPCMD_EXCEPT_ALL" => Some(Self::SetopcmdExceptAll),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SetOpStrategy {
    Undefined = 0,
    SetopSorted = 1,
    SetopHashed = 2,
}
impl SetOpStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "SET_OP_STRATEGY_UNDEFINED",
            Self::SetopSorted => "SETOP_SORTED",
            Self::SetopHashed => "SETOP_HASHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SET_OP_STRATEGY_UNDEFINED" => Some(Self::Undefined),
            "SETOP_SORTED" => Some(Self::SetopSorted),
            "SETOP_HASHED" => Some(Self::SetopHashed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OnConflictAction {
    Undefined = 0,
    OnconflictNone = 1,
    OnconflictNothing = 2,
    OnconflictUpdate = 3,
}
impl OnConflictAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "ON_CONFLICT_ACTION_UNDEFINED",
            Self::OnconflictNone => "ONCONFLICT_NONE",
            Self::OnconflictNothing => "ONCONFLICT_NOTHING",
            Self::OnconflictUpdate => "ONCONFLICT_UPDATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ON_CONFLICT_ACTION_UNDEFINED" => Some(Self::Undefined),
            "ONCONFLICT_NONE" => Some(Self::OnconflictNone),
            "ONCONFLICT_NOTHING" => Some(Self::OnconflictNothing),
            "ONCONFLICT_UPDATE" => Some(Self::OnconflictUpdate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LimitOption {
    Undefined = 0,
    Default = 1,
    Count = 2,
    WithTies = 3,
}
impl LimitOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "LIMIT_OPTION_UNDEFINED",
            Self::Default => "LIMIT_OPTION_DEFAULT",
            Self::Count => "LIMIT_OPTION_COUNT",
            Self::WithTies => "LIMIT_OPTION_WITH_TIES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIMIT_OPTION_UNDEFINED" => Some(Self::Undefined),
            "LIMIT_OPTION_DEFAULT" => Some(Self::Default),
            "LIMIT_OPTION_COUNT" => Some(Self::Count),
            "LIMIT_OPTION_WITH_TIES" => Some(Self::WithTies),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockClauseStrength {
    Undefined = 0,
    LcsNone = 1,
    LcsForkeyshare = 2,
    LcsForshare = 3,
    LcsFornokeyupdate = 4,
    LcsForupdate = 5,
}
impl LockClauseStrength {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "LOCK_CLAUSE_STRENGTH_UNDEFINED",
            Self::LcsNone => "LCS_NONE",
            Self::LcsForkeyshare => "LCS_FORKEYSHARE",
            Self::LcsForshare => "LCS_FORSHARE",
            Self::LcsFornokeyupdate => "LCS_FORNOKEYUPDATE",
            Self::LcsForupdate => "LCS_FORUPDATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCK_CLAUSE_STRENGTH_UNDEFINED" => Some(Self::Undefined),
            "LCS_NONE" => Some(Self::LcsNone),
            "LCS_FORKEYSHARE" => Some(Self::LcsForkeyshare),
            "LCS_FORSHARE" => Some(Self::LcsForshare),
            "LCS_FORNOKEYUPDATE" => Some(Self::LcsFornokeyupdate),
            "LCS_FORUPDATE" => Some(Self::LcsForupdate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockWaitPolicy {
    Undefined = 0,
    LockWaitBlock = 1,
    LockWaitSkip = 2,
    LockWaitError = 3,
}
impl LockWaitPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "LOCK_WAIT_POLICY_UNDEFINED",
            Self::LockWaitBlock => "LockWaitBlock",
            Self::LockWaitSkip => "LockWaitSkip",
            Self::LockWaitError => "LockWaitError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCK_WAIT_POLICY_UNDEFINED" => Some(Self::Undefined),
            "LockWaitBlock" => Some(Self::LockWaitBlock),
            "LockWaitSkip" => Some(Self::LockWaitSkip),
            "LockWaitError" => Some(Self::LockWaitError),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockTupleMode {
    Undefined = 0,
    LockTupleKeyShare = 1,
    LockTupleShare = 2,
    LockTupleNoKeyExclusive = 3,
    LockTupleExclusive = 4,
}
impl LockTupleMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undefined => "LOCK_TUPLE_MODE_UNDEFINED",
            Self::LockTupleKeyShare => "LockTupleKeyShare",
            Self::LockTupleShare => "LockTupleShare",
            Self::LockTupleNoKeyExclusive => "LockTupleNoKeyExclusive",
            Self::LockTupleExclusive => "LockTupleExclusive",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCK_TUPLE_MODE_UNDEFINED" => Some(Self::Undefined),
            "LockTupleKeyShare" => Some(Self::LockTupleKeyShare),
            "LockTupleShare" => Some(Self::LockTupleShare),
            "LockTupleNoKeyExclusive" => Some(Self::LockTupleNoKeyExclusive),
            "LockTupleExclusive" => Some(Self::LockTupleExclusive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeywordKind {
    NoKeyword = 0,
    UnreservedKeyword = 1,
    ColNameKeyword = 2,
    TypeFuncNameKeyword = 3,
    ReservedKeyword = 4,
}
impl KeywordKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoKeyword => "NO_KEYWORD",
            Self::UnreservedKeyword => "UNRESERVED_KEYWORD",
            Self::ColNameKeyword => "COL_NAME_KEYWORD",
            Self::TypeFuncNameKeyword => "TYPE_FUNC_NAME_KEYWORD",
            Self::ReservedKeyword => "RESERVED_KEYWORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_KEYWORD" => Some(Self::NoKeyword),
            "UNRESERVED_KEYWORD" => Some(Self::UnreservedKeyword),
            "COL_NAME_KEYWORD" => Some(Self::ColNameKeyword),
            "TYPE_FUNC_NAME_KEYWORD" => Some(Self::TypeFuncNameKeyword),
            "RESERVED_KEYWORD" => Some(Self::ReservedKeyword),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Token {
    Nul = 0,
    /// Single-character tokens that are returned 1:1 (identical with "self" list in scan.l)
    /// Either supporting syntax, or single-character operators (some can be both)
    /// Also see <https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-SYNTAX-SPECIAL-CHARS>
    ///
    /// "$"
    Ascii36 = 36,
    /// "%"
    Ascii37 = 37,
    /// "("
    Ascii40 = 40,
    /// ")"
    Ascii41 = 41,
    /// "*"
    Ascii42 = 42,
    /// "+"
    Ascii43 = 43,
    /// ","
    Ascii44 = 44,
    /// "-"
    Ascii45 = 45,
    /// "."
    Ascii46 = 46,
    /// "/"
    Ascii47 = 47,
    /// ":"
    Ascii58 = 58,
    /// ";"
    Ascii59 = 59,
    /// "<"
    Ascii60 = 60,
    /// "="
    Ascii61 = 61,
    /// ">"
    Ascii62 = 62,
    /// "?"
    Ascii63 = 63,
    /// "["
    Ascii91 = 91,
    /// "\"
    Ascii92 = 92,
    /// "]"
    Ascii93 = 93,
    /// "^"
    Ascii94 = 94,
    /// Named tokens in scan.l
    Ident = 258,
    Uident = 259,
    Fconst = 260,
    Sconst = 261,
    Usconst = 262,
    Bconst = 263,
    Xconst = 264,
    Op = 265,
    Iconst = 266,
    Param = 267,
    Typecast = 268,
    DotDot = 269,
    ColonEquals = 270,
    EqualsGreater = 271,
    LessEquals = 272,
    GreaterEquals = 273,
    NotEquals = 274,
    SqlComment = 275,
    CComment = 276,
    AbortP = 277,
    Absent = 278,
    AbsoluteP = 279,
    Access = 280,
    Action = 281,
    AddP = 282,
    Admin = 283,
    After = 284,
    Aggregate = 285,
    All = 286,
    Also = 287,
    Alter = 288,
    Always = 289,
    Analyse = 290,
    Analyze = 291,
    And = 292,
    Any = 293,
    Array = 294,
    As = 295,
    Asc = 296,
    Asensitive = 297,
    Assertion = 298,
    Assignment = 299,
    Asymmetric = 300,
    Atomic = 301,
    At = 302,
    Attach = 303,
    Attribute = 304,
    Authorization = 305,
    Backward = 306,
    Before = 307,
    BeginP = 308,
    Between = 309,
    Bigint = 310,
    Binary = 311,
    Bit = 312,
    BooleanP = 313,
    Both = 314,
    Breadth = 315,
    By = 316,
    Cache = 317,
    Call = 318,
    Called = 319,
    Cascade = 320,
    Cascaded = 321,
    Case = 322,
    Cast = 323,
    CatalogP = 324,
    Chain = 325,
    CharP = 326,
    Character = 327,
    Characteristics = 328,
    Check = 329,
    Checkpoint = 330,
    Class = 331,
    Close = 332,
    Cluster = 333,
    Coalesce = 334,
    Collate = 335,
    Collation = 336,
    Column = 337,
    Columns = 338,
    Comment = 339,
    Comments = 340,
    Commit = 341,
    Committed = 342,
    Compression = 343,
    Concurrently = 344,
    Conditional = 345,
    Configuration = 346,
    Conflict = 347,
    Connection = 348,
    Constraint = 349,
    Constraints = 350,
    ContentP = 351,
    ContinueP = 352,
    ConversionP = 353,
    Copy = 354,
    Cost = 355,
    Create = 356,
    Cross = 357,
    Csv = 358,
    Cube = 359,
    CurrentP = 360,
    CurrentCatalog = 361,
    CurrentDate = 362,
    CurrentRole = 363,
    CurrentSchema = 364,
    CurrentTime = 365,
    CurrentTimestamp = 366,
    CurrentUser = 367,
    Cursor = 368,
    Cycle = 369,
    DataP = 370,
    Database = 371,
    DayP = 372,
    Deallocate = 373,
    Dec = 374,
    DecimalP = 375,
    Declare = 376,
    Default = 377,
    Defaults = 378,
    Deferrable = 379,
    Deferred = 380,
    Definer = 381,
    DeleteP = 382,
    Delimiter = 383,
    Delimiters = 384,
    Depends = 385,
    Depth = 386,
    Desc = 387,
    Detach = 388,
    Dictionary = 389,
    DisableP = 390,
    Discard = 391,
    Distinct = 392,
    Do = 393,
    DocumentP = 394,
    DomainP = 395,
    DoubleP = 396,
    Drop = 397,
    Each = 398,
    Else = 399,
    EmptyP = 400,
    EnableP = 401,
    Encoding = 402,
    Encrypted = 403,
    EndP = 404,
    EnumP = 405,
    ErrorP = 406,
    Escape = 407,
    Event = 408,
    Except = 409,
    Exclude = 410,
    Excluding = 411,
    Exclusive = 412,
    Execute = 413,
    Exists = 414,
    Explain = 415,
    Expression = 416,
    Extension = 417,
    External = 418,
    Extract = 419,
    FalseP = 420,
    Family = 421,
    Fetch = 422,
    Filter = 423,
    Finalize = 424,
    FirstP = 425,
    FloatP = 426,
    Following = 427,
    For = 428,
    Force = 429,
    Foreign = 430,
    Format = 431,
    Forward = 432,
    Freeze = 433,
    From = 434,
    Full = 435,
    Function = 436,
    Functions = 437,
    Generated = 438,
    Global = 439,
    Grant = 440,
    Granted = 441,
    Greatest = 442,
    GroupP = 443,
    Grouping = 444,
    Groups = 445,
    Handler = 446,
    Having = 447,
    HeaderP = 448,
    Hold = 449,
    HourP = 450,
    IdentityP = 451,
    IfP = 452,
    Ilike = 453,
    Immediate = 454,
    Immutable = 455,
    ImplicitP = 456,
    ImportP = 457,
    InP = 458,
    Include = 459,
    Including = 460,
    Increment = 461,
    Indent = 462,
    Index = 463,
    Indexes = 464,
    Inherit = 465,
    Inherits = 466,
    Initially = 467,
    InlineP = 468,
    InnerP = 469,
    Inout = 470,
    InputP = 471,
    Insensitive = 472,
    Insert = 473,
    Instead = 474,
    IntP = 475,
    Integer = 476,
    Intersect = 477,
    Interval = 478,
    Into = 479,
    Invoker = 480,
    Is = 481,
    Isnull = 482,
    Isolation = 483,
    Join = 484,
    Json = 485,
    JsonArray = 486,
    JsonArrayagg = 487,
    JsonExists = 488,
    JsonObject = 489,
    JsonObjectagg = 490,
    JsonQuery = 491,
    JsonScalar = 492,
    JsonSerialize = 493,
    JsonTable = 494,
    JsonValue = 495,
    Keep = 496,
    Key = 497,
    Keys = 498,
    Label = 499,
    Language = 500,
    LargeP = 501,
    LastP = 502,
    LateralP = 503,
    Leading = 504,
    Leakproof = 505,
    Least = 506,
    Left = 507,
    Level = 508,
    Like = 509,
    Limit = 510,
    Listen = 511,
    Load = 512,
    Local = 513,
    Localtime = 514,
    Localtimestamp = 515,
    Location = 516,
    LockP = 517,
    Locked = 518,
    Logged = 519,
    Mapping = 520,
    Match = 521,
    Matched = 522,
    Materialized = 523,
    Maxvalue = 524,
    Merge = 525,
    MergeAction = 526,
    Method = 527,
    MinuteP = 528,
    Minvalue = 529,
    Mode = 530,
    MonthP = 531,
    Move = 532,
    NameP = 533,
    Names = 534,
    National = 535,
    Natural = 536,
    Nchar = 537,
    Nested = 538,
    New = 539,
    Next = 540,
    Nfc = 541,
    Nfd = 542,
    Nfkc = 543,
    Nfkd = 544,
    No = 545,
    None = 546,
    Normalize = 547,
    Normalized = 548,
    Not = 549,
    Nothing = 550,
    Notify = 551,
    Notnull = 552,
    Nowait = 553,
    NullP = 554,
    Nullif = 555,
    NullsP = 556,
    Numeric = 557,
    ObjectP = 558,
    Of = 559,
    Off = 560,
    Offset = 561,
    Oids = 562,
    Old = 563,
    Omit = 564,
    On = 565,
    Only = 566,
    Operator = 567,
    Option = 568,
    Options = 569,
    Or = 570,
    Order = 571,
    Ordinality = 572,
    Others = 573,
    OutP = 574,
    OuterP = 575,
    Over = 576,
    Overlaps = 577,
    Overlay = 578,
    Overriding = 579,
    Owned = 580,
    Owner = 581,
    Parallel = 582,
    Parameter = 583,
    Parser = 584,
    Partial = 585,
    Partition = 586,
    Passing = 587,
    Password = 588,
    Path = 589,
    Placing = 590,
    Plan = 591,
    Plans = 592,
    Policy = 593,
    Position = 594,
    Preceding = 595,
    Precision = 596,
    Preserve = 597,
    Prepare = 598,
    Prepared = 599,
    Primary = 600,
    Prior = 601,
    Privileges = 602,
    Procedural = 603,
    Procedure = 604,
    Procedures = 605,
    Program = 606,
    Publication = 607,
    Quote = 608,
    Quotes = 609,
    Range = 610,
    Read = 611,
    Real = 612,
    Reassign = 613,
    Recheck = 614,
    Recursive = 615,
    RefP = 616,
    References = 617,
    Referencing = 618,
    Refresh = 619,
    Reindex = 620,
    RelativeP = 621,
    Release = 622,
    Rename = 623,
    Repeatable = 624,
    Replace = 625,
    Replica = 626,
    Reset = 627,
    Restart = 628,
    Restrict = 629,
    Return = 630,
    Returning = 631,
    Returns = 632,
    Revoke = 633,
    Right = 634,
    Role = 635,
    Rollback = 636,
    Rollup = 637,
    Routine = 638,
    Routines = 639,
    Row = 640,
    Rows = 641,
    Rule = 642,
    Savepoint = 643,
    Scalar = 644,
    Schema = 645,
    Schemas = 646,
    Scroll = 647,
    Search = 648,
    SecondP = 649,
    Security = 650,
    Select = 651,
    Sequence = 652,
    Sequences = 653,
    Serializable = 654,
    Server = 655,
    Session = 656,
    SessionUser = 657,
    Set = 658,
    Sets = 659,
    Setof = 660,
    Share = 661,
    Show = 662,
    Similar = 663,
    Simple = 664,
    Skip = 665,
    Smallint = 666,
    Snapshot = 667,
    Some = 668,
    Source = 669,
    SqlP = 670,
    Stable = 671,
    StandaloneP = 672,
    Start = 673,
    Statement = 674,
    Statistics = 675,
    Stdin = 676,
    Stdout = 677,
    Storage = 678,
    Stored = 679,
    StrictP = 680,
    StringP = 681,
    StripP = 682,
    Subscription = 683,
    Substring = 684,
    Support = 685,
    Symmetric = 686,
    Sysid = 687,
    SystemP = 688,
    SystemUser = 689,
    Table = 690,
    Tables = 691,
    Tablesample = 692,
    Tablespace = 693,
    Target = 694,
    Temp = 695,
    Template = 696,
    Temporary = 697,
    TextP = 698,
    Then = 699,
    Ties = 700,
    Time = 701,
    Timestamp = 702,
    To = 703,
    Trailing = 704,
    Transaction = 705,
    Transform = 706,
    Treat = 707,
    Trigger = 708,
    Trim = 709,
    TrueP = 710,
    Truncate = 711,
    Trusted = 712,
    TypeP = 713,
    TypesP = 714,
    Uescape = 715,
    Unbounded = 716,
    Unconditional = 717,
    Uncommitted = 718,
    Unencrypted = 719,
    Union = 720,
    Unique = 721,
    Unknown = 722,
    Unlisten = 723,
    Unlogged = 724,
    Until = 725,
    Update = 726,
    User = 727,
    Using = 728,
    Vacuum = 729,
    Valid = 730,
    Validate = 731,
    Validator = 732,
    ValueP = 733,
    Values = 734,
    Varchar = 735,
    Variadic = 736,
    Varying = 737,
    Verbose = 738,
    VersionP = 739,
    View = 740,
    Views = 741,
    Volatile = 742,
    When = 743,
    Where = 744,
    WhitespaceP = 745,
    Window = 746,
    With = 747,
    Within = 748,
    Without = 749,
    Work = 750,
    Wrapper = 751,
    Write = 752,
    XmlP = 753,
    Xmlattributes = 754,
    Xmlconcat = 755,
    Xmlelement = 756,
    Xmlexists = 757,
    Xmlforest = 758,
    Xmlnamespaces = 759,
    Xmlparse = 760,
    Xmlpi = 761,
    Xmlroot = 762,
    Xmlserialize = 763,
    Xmltable = 764,
    YearP = 765,
    YesP = 766,
    Zone = 767,
    FormatLa = 768,
    NotLa = 769,
    NullsLa = 770,
    WithLa = 771,
    WithoutLa = 772,
    ModeTypeName = 773,
    ModePlpgsqlExpr = 774,
    ModePlpgsqlAssign1 = 775,
    ModePlpgsqlAssign2 = 776,
    ModePlpgsqlAssign3 = 777,
    Uminus = 778,
}
impl Token {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Nul => "NUL",
            Self::Ascii36 => "ASCII_36",
            Self::Ascii37 => "ASCII_37",
            Self::Ascii40 => "ASCII_40",
            Self::Ascii41 => "ASCII_41",
            Self::Ascii42 => "ASCII_42",
            Self::Ascii43 => "ASCII_43",
            Self::Ascii44 => "ASCII_44",
            Self::Ascii45 => "ASCII_45",
            Self::Ascii46 => "ASCII_46",
            Self::Ascii47 => "ASCII_47",
            Self::Ascii58 => "ASCII_58",
            Self::Ascii59 => "ASCII_59",
            Self::Ascii60 => "ASCII_60",
            Self::Ascii61 => "ASCII_61",
            Self::Ascii62 => "ASCII_62",
            Self::Ascii63 => "ASCII_63",
            Self::Ascii91 => "ASCII_91",
            Self::Ascii92 => "ASCII_92",
            Self::Ascii93 => "ASCII_93",
            Self::Ascii94 => "ASCII_94",
            Self::Ident => "IDENT",
            Self::Uident => "UIDENT",
            Self::Fconst => "FCONST",
            Self::Sconst => "SCONST",
            Self::Usconst => "USCONST",
            Self::Bconst => "BCONST",
            Self::Xconst => "XCONST",
            Self::Op => "Op",
            Self::Iconst => "ICONST",
            Self::Param => "PARAM",
            Self::Typecast => "TYPECAST",
            Self::DotDot => "DOT_DOT",
            Self::ColonEquals => "COLON_EQUALS",
            Self::EqualsGreater => "EQUALS_GREATER",
            Self::LessEquals => "LESS_EQUALS",
            Self::GreaterEquals => "GREATER_EQUALS",
            Self::NotEquals => "NOT_EQUALS",
            Self::SqlComment => "SQL_COMMENT",
            Self::CComment => "C_COMMENT",
            Self::AbortP => "ABORT_P",
            Self::Absent => "ABSENT",
            Self::AbsoluteP => "ABSOLUTE_P",
            Self::Access => "ACCESS",
            Self::Action => "ACTION",
            Self::AddP => "ADD_P",
            Self::Admin => "ADMIN",
            Self::After => "AFTER",
            Self::Aggregate => "AGGREGATE",
            Self::All => "ALL",
            Self::Also => "ALSO",
            Self::Alter => "ALTER",
            Self::Always => "ALWAYS",
            Self::Analyse => "ANALYSE",
            Self::Analyze => "ANALYZE",
            Self::And => "AND",
            Self::Any => "ANY",
            Self::Array => "ARRAY",
            Self::As => "AS",
            Self::Asc => "ASC",
            Self::Asensitive => "ASENSITIVE",
            Self::Assertion => "ASSERTION",
            Self::Assignment => "ASSIGNMENT",
            Self::Asymmetric => "ASYMMETRIC",
            Self::Atomic => "ATOMIC",
            Self::At => "AT",
            Self::Attach => "ATTACH",
            Self::Attribute => "ATTRIBUTE",
            Self::Authorization => "AUTHORIZATION",
            Self::Backward => "BACKWARD",
            Self::Before => "BEFORE",
            Self::BeginP => "BEGIN_P",
            Self::Between => "BETWEEN",
            Self::Bigint => "BIGINT",
            Self::Binary => "BINARY",
            Self::Bit => "BIT",
            Self::BooleanP => "BOOLEAN_P",
            Self::Both => "BOTH",
            Self::Breadth => "BREADTH",
            Self::By => "BY",
            Self::Cache => "CACHE",
            Self::Call => "CALL",
            Self::Called => "CALLED",
            Self::Cascade => "CASCADE",
            Self::Cascaded => "CASCADED",
            Self::Case => "CASE",
            Self::Cast => "CAST",
            Self::CatalogP => "CATALOG_P",
            Self::Chain => "CHAIN",
            Self::CharP => "CHAR_P",
            Self::Character => "CHARACTER",
            Self::Characteristics => "CHARACTERISTICS",
            Self::Check => "CHECK",
            Self::Checkpoint => "CHECKPOINT",
            Self::Class => "CLASS",
            Self::Close => "CLOSE",
            Self::Cluster => "CLUSTER",
            Self::Coalesce => "COALESCE",
            Self::Collate => "COLLATE",
            Self::Collation => "COLLATION",
            Self::Column => "COLUMN",
            Self::Columns => "COLUMNS",
            Self::Comment => "COMMENT",
            Self::Comments => "COMMENTS",
            Self::Commit => "COMMIT",
            Self::Committed => "COMMITTED",
            Self::Compression => "COMPRESSION",
            Self::Concurrently => "CONCURRENTLY",
            Self::Conditional => "CONDITIONAL",
            Self::Configuration => "CONFIGURATION",
            Self::Conflict => "CONFLICT",
            Self::Connection => "CONNECTION",
            Self::Constraint => "CONSTRAINT",
            Self::Constraints => "CONSTRAINTS",
            Self::ContentP => "CONTENT_P",
            Self::ContinueP => "CONTINUE_P",
            Self::ConversionP => "CONVERSION_P",
            Self::Copy => "COPY",
            Self::Cost => "COST",
            Self::Create => "CREATE",
            Self::Cross => "CROSS",
            Self::Csv => "CSV",
            Self::Cube => "CUBE",
            Self::CurrentP => "CURRENT_P",
            Self::CurrentCatalog => "CURRENT_CATALOG",
            Self::CurrentDate => "CURRENT_DATE",
            Self::CurrentRole => "CURRENT_ROLE",
            Self::CurrentSchema => "CURRENT_SCHEMA",
            Self::CurrentTime => "CURRENT_TIME",
            Self::CurrentTimestamp => "CURRENT_TIMESTAMP",
            Self::CurrentUser => "CURRENT_USER",
            Self::Cursor => "CURSOR",
            Self::Cycle => "CYCLE",
            Self::DataP => "DATA_P",
            Self::Database => "DATABASE",
            Self::DayP => "DAY_P",
            Self::Deallocate => "DEALLOCATE",
            Self::Dec => "DEC",
            Self::DecimalP => "DECIMAL_P",
            Self::Declare => "DECLARE",
            Self::Default => "DEFAULT",
            Self::Defaults => "DEFAULTS",
            Self::Deferrable => "DEFERRABLE",
            Self::Deferred => "DEFERRED",
            Self::Definer => "DEFINER",
            Self::DeleteP => "DELETE_P",
            Self::Delimiter => "DELIMITER",
            Self::Delimiters => "DELIMITERS",
            Self::Depends => "DEPENDS",
            Self::Depth => "DEPTH",
            Self::Desc => "DESC",
            Self::Detach => "DETACH",
            Self::Dictionary => "DICTIONARY",
            Self::DisableP => "DISABLE_P",
            Self::Discard => "DISCARD",
            Self::Distinct => "DISTINCT",
            Self::Do => "DO",
            Self::DocumentP => "DOCUMENT_P",
            Self::DomainP => "DOMAIN_P",
            Self::DoubleP => "DOUBLE_P",
            Self::Drop => "DROP",
            Self::Each => "EACH",
            Self::Else => "ELSE",
            Self::EmptyP => "EMPTY_P",
            Self::EnableP => "ENABLE_P",
            Self::Encoding => "ENCODING",
            Self::Encrypted => "ENCRYPTED",
            Self::EndP => "END_P",
            Self::EnumP => "ENUM_P",
            Self::ErrorP => "ERROR_P",
            Self::Escape => "ESCAPE",
            Self::Event => "EVENT",
            Self::Except => "EXCEPT",
            Self::Exclude => "EXCLUDE",
            Self::Excluding => "EXCLUDING",
            Self::Exclusive => "EXCLUSIVE",
            Self::Execute => "EXECUTE",
            Self::Exists => "EXISTS",
            Self::Explain => "EXPLAIN",
            Self::Expression => "EXPRESSION",
            Self::Extension => "EXTENSION",
            Self::External => "EXTERNAL",
            Self::Extract => "EXTRACT",
            Self::FalseP => "FALSE_P",
            Self::Family => "FAMILY",
            Self::Fetch => "FETCH",
            Self::Filter => "FILTER",
            Self::Finalize => "FINALIZE",
            Self::FirstP => "FIRST_P",
            Self::FloatP => "FLOAT_P",
            Self::Following => "FOLLOWING",
            Self::For => "FOR",
            Self::Force => "FORCE",
            Self::Foreign => "FOREIGN",
            Self::Format => "FORMAT",
            Self::Forward => "FORWARD",
            Self::Freeze => "FREEZE",
            Self::From => "FROM",
            Self::Full => "FULL",
            Self::Function => "FUNCTION",
            Self::Functions => "FUNCTIONS",
            Self::Generated => "GENERATED",
            Self::Global => "GLOBAL",
            Self::Grant => "GRANT",
            Self::Granted => "GRANTED",
            Self::Greatest => "GREATEST",
            Self::GroupP => "GROUP_P",
            Self::Grouping => "GROUPING",
            Self::Groups => "GROUPS",
            Self::Handler => "HANDLER",
            Self::Having => "HAVING",
            Self::HeaderP => "HEADER_P",
            Self::Hold => "HOLD",
            Self::HourP => "HOUR_P",
            Self::IdentityP => "IDENTITY_P",
            Self::IfP => "IF_P",
            Self::Ilike => "ILIKE",
            Self::Immediate => "IMMEDIATE",
            Self::Immutable => "IMMUTABLE",
            Self::ImplicitP => "IMPLICIT_P",
            Self::ImportP => "IMPORT_P",
            Self::InP => "IN_P",
            Self::Include => "INCLUDE",
            Self::Including => "INCLUDING",
            Self::Increment => "INCREMENT",
            Self::Indent => "INDENT",
            Self::Index => "INDEX",
            Self::Indexes => "INDEXES",
            Self::Inherit => "INHERIT",
            Self::Inherits => "INHERITS",
            Self::Initially => "INITIALLY",
            Self::InlineP => "INLINE_P",
            Self::InnerP => "INNER_P",
            Self::Inout => "INOUT",
            Self::InputP => "INPUT_P",
            Self::Insensitive => "INSENSITIVE",
            Self::Insert => "INSERT",
            Self::Instead => "INSTEAD",
            Self::IntP => "INT_P",
            Self::Integer => "INTEGER",
            Self::Intersect => "INTERSECT",
            Self::Interval => "INTERVAL",
            Self::Into => "INTO",
            Self::Invoker => "INVOKER",
            Self::Is => "IS",
            Self::Isnull => "ISNULL",
            Self::Isolation => "ISOLATION",
            Self::Join => "JOIN",
            Self::Json => "JSON",
            Self::JsonArray => "JSON_ARRAY",
            Self::JsonArrayagg => "JSON_ARRAYAGG",
            Self::JsonExists => "JSON_EXISTS",
            Self::JsonObject => "JSON_OBJECT",
            Self::JsonObjectagg => "JSON_OBJECTAGG",
            Self::JsonQuery => "JSON_QUERY",
            Self::JsonScalar => "JSON_SCALAR",
            Self::JsonSerialize => "JSON_SERIALIZE",
            Self::JsonTable => "JSON_TABLE",
            Self::JsonValue => "JSON_VALUE",
            Self::Keep => "KEEP",
            Self::Key => "KEY",
            Self::Keys => "KEYS",
            Self::Label => "LABEL",
            Self::Language => "LANGUAGE",
            Self::LargeP => "LARGE_P",
            Self::LastP => "LAST_P",
            Self::LateralP => "LATERAL_P",
            Self::Leading => "LEADING",
            Self::Leakproof => "LEAKPROOF",
            Self::Least => "LEAST",
            Self::Left => "LEFT",
            Self::Level => "LEVEL",
            Self::Like => "LIKE",
            Self::Limit => "LIMIT",
            Self::Listen => "LISTEN",
            Self::Load => "LOAD",
            Self::Local => "LOCAL",
            Self::Localtime => "LOCALTIME",
            Self::Localtimestamp => "LOCALTIMESTAMP",
            Self::Location => "LOCATION",
            Self::LockP => "LOCK_P",
            Self::Locked => "LOCKED",
            Self::Logged => "LOGGED",
            Self::Mapping => "MAPPING",
            Self::Match => "MATCH",
            Self::Matched => "MATCHED",
            Self::Materialized => "MATERIALIZED",
            Self::Maxvalue => "MAXVALUE",
            Self::Merge => "MERGE",
            Self::MergeAction => "MERGE_ACTION",
            Self::Method => "METHOD",
            Self::MinuteP => "MINUTE_P",
            Self::Minvalue => "MINVALUE",
            Self::Mode => "MODE",
            Self::MonthP => "MONTH_P",
            Self::Move => "MOVE",
            Self::NameP => "NAME_P",
            Self::Names => "NAMES",
            Self::National => "NATIONAL",
            Self::Natural => "NATURAL",
            Self::Nchar => "NCHAR",
            Self::Nested => "NESTED",
            Self::New => "NEW",
            Self::Next => "NEXT",
            Self::Nfc => "NFC",
            Self::Nfd => "NFD",
            Self::Nfkc => "NFKC",
            Self::Nfkd => "NFKD",
            Self::No => "NO",
            Self::None => "NONE",
            Self::Normalize => "NORMALIZE",
            Self::Normalized => "NORMALIZED",
            Self::Not => "NOT",
            Self::Nothing => "NOTHING",
            Self::Notify => "NOTIFY",
            Self::Notnull => "NOTNULL",
            Self::Nowait => "NOWAIT",
            Self::NullP => "NULL_P",
            Self::Nullif => "NULLIF",
            Self::NullsP => "NULLS_P",
            Self::Numeric => "NUMERIC",
            Self::ObjectP => "OBJECT_P",
            Self::Of => "OF",
            Self::Off => "OFF",
            Self::Offset => "OFFSET",
            Self::Oids => "OIDS",
            Self::Old => "OLD",
            Self::Omit => "OMIT",
            Self::On => "ON",
            Self::Only => "ONLY",
            Self::Operator => "OPERATOR",
            Self::Option => "OPTION",
            Self::Options => "OPTIONS",
            Self::Or => "OR",
            Self::Order => "ORDER",
            Self::Ordinality => "ORDINALITY",
            Self::Others => "OTHERS",
            Self::OutP => "OUT_P",
            Self::OuterP => "OUTER_P",
            Self::Over => "OVER",
            Self::Overlaps => "OVERLAPS",
            Self::Overlay => "OVERLAY",
            Self::Overriding => "OVERRIDING",
            Self::Owned => "OWNED",
            Self::Owner => "OWNER",
            Self::Parallel => "PARALLEL",
            Self::Parameter => "PARAMETER",
            Self::Parser => "PARSER",
            Self::Partial => "PARTIAL",
            Self::Partition => "PARTITION",
            Self::Passing => "PASSING",
            Self::Password => "PASSWORD",
            Self::Path => "PATH",
            Self::Placing => "PLACING",
            Self::Plan => "PLAN",
            Self::Plans => "PLANS",
            Self::Policy => "POLICY",
            Self::Position => "POSITION",
            Self::Preceding => "PRECEDING",
            Self::Precision => "PRECISION",
            Self::Preserve => "PRESERVE",
            Self::Prepare => "PREPARE",
            Self::Prepared => "PREPARED",
            Self::Primary => "PRIMARY",
            Self::Prior => "PRIOR",
            Self::Privileges => "PRIVILEGES",
            Self::Procedural => "PROCEDURAL",
            Self::Procedure => "PROCEDURE",
            Self::Procedures => "PROCEDURES",
            Self::Program => "PROGRAM",
            Self::Publication => "PUBLICATION",
            Self::Quote => "QUOTE",
            Self::Quotes => "QUOTES",
            Self::Range => "RANGE",
            Self::Read => "READ",
            Self::Real => "REAL",
            Self::Reassign => "REASSIGN",
            Self::Recheck => "RECHECK",
            Self::Recursive => "RECURSIVE",
            Self::RefP => "REF_P",
            Self::References => "REFERENCES",
            Self::Referencing => "REFERENCING",
            Self::Refresh => "REFRESH",
            Self::Reindex => "REINDEX",
            Self::RelativeP => "RELATIVE_P",
            Self::Release => "RELEASE",
            Self::Rename => "RENAME",
            Self::Repeatable => "REPEATABLE",
            Self::Replace => "REPLACE",
            Self::Replica => "REPLICA",
            Self::Reset => "RESET",
            Self::Restart => "RESTART",
            Self::Restrict => "RESTRICT",
            Self::Return => "RETURN",
            Self::Returning => "RETURNING",
            Self::Returns => "RETURNS",
            Self::Revoke => "REVOKE",
            Self::Right => "RIGHT",
            Self::Role => "ROLE",
            Self::Rollback => "ROLLBACK",
            Self::Rollup => "ROLLUP",
            Self::Routine => "ROUTINE",
            Self::Routines => "ROUTINES",
            Self::Row => "ROW",
            Self::Rows => "ROWS",
            Self::Rule => "RULE",
            Self::Savepoint => "SAVEPOINT",
            Self::Scalar => "SCALAR",
            Self::Schema => "SCHEMA",
            Self::Schemas => "SCHEMAS",
            Self::Scroll => "SCROLL",
            Self::Search => "SEARCH",
            Self::SecondP => "SECOND_P",
            Self::Security => "SECURITY",
            Self::Select => "SELECT",
            Self::Sequence => "SEQUENCE",
            Self::Sequences => "SEQUENCES",
            Self::Serializable => "SERIALIZABLE",
            Self::Server => "SERVER",
            Self::Session => "SESSION",
            Self::SessionUser => "SESSION_USER",
            Self::Set => "SET",
            Self::Sets => "SETS",
            Self::Setof => "SETOF",
            Self::Share => "SHARE",
            Self::Show => "SHOW",
            Self::Similar => "SIMILAR",
            Self::Simple => "SIMPLE",
            Self::Skip => "SKIP",
            Self::Smallint => "SMALLINT",
            Self::Snapshot => "SNAPSHOT",
            Self::Some => "SOME",
            Self::Source => "SOURCE",
            Self::SqlP => "SQL_P",
            Self::Stable => "STABLE",
            Self::StandaloneP => "STANDALONE_P",
            Self::Start => "START",
            Self::Statement => "STATEMENT",
            Self::Statistics => "STATISTICS",
            Self::Stdin => "STDIN",
            Self::Stdout => "STDOUT",
            Self::Storage => "STORAGE",
            Self::Stored => "STORED",
            Self::StrictP => "STRICT_P",
            Self::StringP => "STRING_P",
            Self::StripP => "STRIP_P",
            Self::Subscription => "SUBSCRIPTION",
            Self::Substring => "SUBSTRING",
            Self::Support => "SUPPORT",
            Self::Symmetric => "SYMMETRIC",
            Self::Sysid => "SYSID",
            Self::SystemP => "SYSTEM_P",
            Self::SystemUser => "SYSTEM_USER",
            Self::Table => "TABLE",
            Self::Tables => "TABLES",
            Self::Tablesample => "TABLESAMPLE",
            Self::Tablespace => "TABLESPACE",
            Self::Target => "TARGET",
            Self::Temp => "TEMP",
            Self::Template => "TEMPLATE",
            Self::Temporary => "TEMPORARY",
            Self::TextP => "TEXT_P",
            Self::Then => "THEN",
            Self::Ties => "TIES",
            Self::Time => "TIME",
            Self::Timestamp => "TIMESTAMP",
            Self::To => "TO",
            Self::Trailing => "TRAILING",
            Self::Transaction => "TRANSACTION",
            Self::Transform => "TRANSFORM",
            Self::Treat => "TREAT",
            Self::Trigger => "TRIGGER",
            Self::Trim => "TRIM",
            Self::TrueP => "TRUE_P",
            Self::Truncate => "TRUNCATE",
            Self::Trusted => "TRUSTED",
            Self::TypeP => "TYPE_P",
            Self::TypesP => "TYPES_P",
            Self::Uescape => "UESCAPE",
            Self::Unbounded => "UNBOUNDED",
            Self::Unconditional => "UNCONDITIONAL",
            Self::Uncommitted => "UNCOMMITTED",
            Self::Unencrypted => "UNENCRYPTED",
            Self::Union => "UNION",
            Self::Unique => "UNIQUE",
            Self::Unknown => "UNKNOWN",
            Self::Unlisten => "UNLISTEN",
            Self::Unlogged => "UNLOGGED",
            Self::Until => "UNTIL",
            Self::Update => "UPDATE",
            Self::User => "USER",
            Self::Using => "USING",
            Self::Vacuum => "VACUUM",
            Self::Valid => "VALID",
            Self::Validate => "VALIDATE",
            Self::Validator => "VALIDATOR",
            Self::ValueP => "VALUE_P",
            Self::Values => "VALUES",
            Self::Varchar => "VARCHAR",
            Self::Variadic => "VARIADIC",
            Self::Varying => "VARYING",
            Self::Verbose => "VERBOSE",
            Self::VersionP => "VERSION_P",
            Self::View => "VIEW",
            Self::Views => "VIEWS",
            Self::Volatile => "VOLATILE",
            Self::When => "WHEN",
            Self::Where => "WHERE",
            Self::WhitespaceP => "WHITESPACE_P",
            Self::Window => "WINDOW",
            Self::With => "WITH",
            Self::Within => "WITHIN",
            Self::Without => "WITHOUT",
            Self::Work => "WORK",
            Self::Wrapper => "WRAPPER",
            Self::Write => "WRITE",
            Self::XmlP => "XML_P",
            Self::Xmlattributes => "XMLATTRIBUTES",
            Self::Xmlconcat => "XMLCONCAT",
            Self::Xmlelement => "XMLELEMENT",
            Self::Xmlexists => "XMLEXISTS",
            Self::Xmlforest => "XMLFOREST",
            Self::Xmlnamespaces => "XMLNAMESPACES",
            Self::Xmlparse => "XMLPARSE",
            Self::Xmlpi => "XMLPI",
            Self::Xmlroot => "XMLROOT",
            Self::Xmlserialize => "XMLSERIALIZE",
            Self::Xmltable => "XMLTABLE",
            Self::YearP => "YEAR_P",
            Self::YesP => "YES_P",
            Self::Zone => "ZONE",
            Self::FormatLa => "FORMAT_LA",
            Self::NotLa => "NOT_LA",
            Self::NullsLa => "NULLS_LA",
            Self::WithLa => "WITH_LA",
            Self::WithoutLa => "WITHOUT_LA",
            Self::ModeTypeName => "MODE_TYPE_NAME",
            Self::ModePlpgsqlExpr => "MODE_PLPGSQL_EXPR",
            Self::ModePlpgsqlAssign1 => "MODE_PLPGSQL_ASSIGN1",
            Self::ModePlpgsqlAssign2 => "MODE_PLPGSQL_ASSIGN2",
            Self::ModePlpgsqlAssign3 => "MODE_PLPGSQL_ASSIGN3",
            Self::Uminus => "UMINUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NUL" => Some(Self::Nul),
            "ASCII_36" => Some(Self::Ascii36),
            "ASCII_37" => Some(Self::Ascii37),
            "ASCII_40" => Some(Self::Ascii40),
            "ASCII_41" => Some(Self::Ascii41),
            "ASCII_42" => Some(Self::Ascii42),
            "ASCII_43" => Some(Self::Ascii43),
            "ASCII_44" => Some(Self::Ascii44),
            "ASCII_45" => Some(Self::Ascii45),
            "ASCII_46" => Some(Self::Ascii46),
            "ASCII_47" => Some(Self::Ascii47),
            "ASCII_58" => Some(Self::Ascii58),
            "ASCII_59" => Some(Self::Ascii59),
            "ASCII_60" => Some(Self::Ascii60),
            "ASCII_61" => Some(Self::Ascii61),
            "ASCII_62" => Some(Self::Ascii62),
            "ASCII_63" => Some(Self::Ascii63),
            "ASCII_91" => Some(Self::Ascii91),
            "ASCII_92" => Some(Self::Ascii92),
            "ASCII_93" => Some(Self::Ascii93),
            "ASCII_94" => Some(Self::Ascii94),
            "IDENT" => Some(Self::Ident),
            "UIDENT" => Some(Self::Uident),
            "FCONST" => Some(Self::Fconst),
            "SCONST" => Some(Self::Sconst),
            "USCONST" => Some(Self::Usconst),
            "BCONST" => Some(Self::Bconst),
            "XCONST" => Some(Self::Xconst),
            "Op" => Some(Self::Op),
            "ICONST" => Some(Self::Iconst),
            "PARAM" => Some(Self::Param),
            "TYPECAST" => Some(Self::Typecast),
            "DOT_DOT" => Some(Self::DotDot),
            "COLON_EQUALS" => Some(Self::ColonEquals),
            "EQUALS_GREATER" => Some(Self::EqualsGreater),
            "LESS_EQUALS" => Some(Self::LessEquals),
            "GREATER_EQUALS" => Some(Self::GreaterEquals),
            "NOT_EQUALS" => Some(Self::NotEquals),
            "SQL_COMMENT" => Some(Self::SqlComment),
            "C_COMMENT" => Some(Self::CComment),
            "ABORT_P" => Some(Self::AbortP),
            "ABSENT" => Some(Self::Absent),
            "ABSOLUTE_P" => Some(Self::AbsoluteP),
            "ACCESS" => Some(Self::Access),
            "ACTION" => Some(Self::Action),
            "ADD_P" => Some(Self::AddP),
            "ADMIN" => Some(Self::Admin),
            "AFTER" => Some(Self::After),
            "AGGREGATE" => Some(Self::Aggregate),
            "ALL" => Some(Self::All),
            "ALSO" => Some(Self::Also),
            "ALTER" => Some(Self::Alter),
            "ALWAYS" => Some(Self::Always),
            "ANALYSE" => Some(Self::Analyse),
            "ANALYZE" => Some(Self::Analyze),
            "AND" => Some(Self::And),
            "ANY" => Some(Self::Any),
            "ARRAY" => Some(Self::Array),
            "AS" => Some(Self::As),
            "ASC" => Some(Self::Asc),
            "ASENSITIVE" => Some(Self::Asensitive),
            "ASSERTION" => Some(Self::Assertion),
            "ASSIGNMENT" => Some(Self::Assignment),
            "ASYMMETRIC" => Some(Self::Asymmetric),
            "ATOMIC" => Some(Self::Atomic),
            "AT" => Some(Self::At),
            "ATTACH" => Some(Self::Attach),
            "ATTRIBUTE" => Some(Self::Attribute),
            "AUTHORIZATION" => Some(Self::Authorization),
            "BACKWARD" => Some(Self::Backward),
            "BEFORE" => Some(Self::Before),
            "BEGIN_P" => Some(Self::BeginP),
            "BETWEEN" => Some(Self::Between),
            "BIGINT" => Some(Self::Bigint),
            "BINARY" => Some(Self::Binary),
            "BIT" => Some(Self::Bit),
            "BOOLEAN_P" => Some(Self::BooleanP),
            "BOTH" => Some(Self::Both),
            "BREADTH" => Some(Self::Breadth),
            "BY" => Some(Self::By),
            "CACHE" => Some(Self::Cache),
            "CALL" => Some(Self::Call),
            "CALLED" => Some(Self::Called),
            "CASCADE" => Some(Self::Cascade),
            "CASCADED" => Some(Self::Cascaded),
            "CASE" => Some(Self::Case),
            "CAST" => Some(Self::Cast),
            "CATALOG_P" => Some(Self::CatalogP),
            "CHAIN" => Some(Self::Chain),
            "CHAR_P" => Some(Self::CharP),
            "CHARACTER" => Some(Self::Character),
            "CHARACTERISTICS" => Some(Self::Characteristics),
            "CHECK" => Some(Self::Check),
            "CHECKPOINT" => Some(Self::Checkpoint),
            "CLASS" => Some(Self::Class),
            "CLOSE" => Some(Self::Close),
            "CLUSTER" => Some(Self::Cluster),
            "COALESCE" => Some(Self::Coalesce),
            "COLLATE" => Some(Self::Collate),
            "COLLATION" => Some(Self::Collation),
            "COLUMN" => Some(Self::Column),
            "COLUMNS" => Some(Self::Columns),
            "COMMENT" => Some(Self::Comment),
            "COMMENTS" => Some(Self::Comments),
            "COMMIT" => Some(Self::Commit),
            "COMMITTED" => Some(Self::Committed),
            "COMPRESSION" => Some(Self::Compression),
            "CONCURRENTLY" => Some(Self::Concurrently),
            "CONDITIONAL" => Some(Self::Conditional),
            "CONFIGURATION" => Some(Self::Configuration),
            "CONFLICT" => Some(Self::Conflict),
            "CONNECTION" => Some(Self::Connection),
            "CONSTRAINT" => Some(Self::Constraint),
            "CONSTRAINTS" => Some(Self::Constraints),
            "CONTENT_P" => Some(Self::ContentP),
            "CONTINUE_P" => Some(Self::ContinueP),
            "CONVERSION_P" => Some(Self::ConversionP),
            "COPY" => Some(Self::Copy),
            "COST" => Some(Self::Cost),
            "CREATE" => Some(Self::Create),
            "CROSS" => Some(Self::Cross),
            "CSV" => Some(Self::Csv),
            "CUBE" => Some(Self::Cube),
            "CURRENT_P" => Some(Self::CurrentP),
            "CURRENT_CATALOG" => Some(Self::CurrentCatalog),
            "CURRENT_DATE" => Some(Self::CurrentDate),
            "CURRENT_ROLE" => Some(Self::CurrentRole),
            "CURRENT_SCHEMA" => Some(Self::CurrentSchema),
            "CURRENT_TIME" => Some(Self::CurrentTime),
            "CURRENT_TIMESTAMP" => Some(Self::CurrentTimestamp),
            "CURRENT_USER" => Some(Self::CurrentUser),
            "CURSOR" => Some(Self::Cursor),
            "CYCLE" => Some(Self::Cycle),
            "DATA_P" => Some(Self::DataP),
            "DATABASE" => Some(Self::Database),
            "DAY_P" => Some(Self::DayP),
            "DEALLOCATE" => Some(Self::Deallocate),
            "DEC" => Some(Self::Dec),
            "DECIMAL_P" => Some(Self::DecimalP),
            "DECLARE" => Some(Self::Declare),
            "DEFAULT" => Some(Self::Default),
            "DEFAULTS" => Some(Self::Defaults),
            "DEFERRABLE" => Some(Self::Deferrable),
            "DEFERRED" => Some(Self::Deferred),
            "DEFINER" => Some(Self::Definer),
            "DELETE_P" => Some(Self::DeleteP),
            "DELIMITER" => Some(Self::Delimiter),
            "DELIMITERS" => Some(Self::Delimiters),
            "DEPENDS" => Some(Self::Depends),
            "DEPTH" => Some(Self::Depth),
            "DESC" => Some(Self::Desc),
            "DETACH" => Some(Self::Detach),
            "DICTIONARY" => Some(Self::Dictionary),
            "DISABLE_P" => Some(Self::DisableP),
            "DISCARD" => Some(Self::Discard),
            "DISTINCT" => Some(Self::Distinct),
            "DO" => Some(Self::Do),
            "DOCUMENT_P" => Some(Self::DocumentP),
            "DOMAIN_P" => Some(Self::DomainP),
            "DOUBLE_P" => Some(Self::DoubleP),
            "DROP" => Some(Self::Drop),
            "EACH" => Some(Self::Each),
            "ELSE" => Some(Self::Else),
            "EMPTY_P" => Some(Self::EmptyP),
            "ENABLE_P" => Some(Self::EnableP),
            "ENCODING" => Some(Self::Encoding),
            "ENCRYPTED" => Some(Self::Encrypted),
            "END_P" => Some(Self::EndP),
            "ENUM_P" => Some(Self::EnumP),
            "ERROR_P" => Some(Self::ErrorP),
            "ESCAPE" => Some(Self::Escape),
            "EVENT" => Some(Self::Event),
            "EXCEPT" => Some(Self::Except),
            "EXCLUDE" => Some(Self::Exclude),
            "EXCLUDING" => Some(Self::Excluding),
            "EXCLUSIVE" => Some(Self::Exclusive),
            "EXECUTE" => Some(Self::Execute),
            "EXISTS" => Some(Self::Exists),
            "EXPLAIN" => Some(Self::Explain),
            "EXPRESSION" => Some(Self::Expression),
            "EXTENSION" => Some(Self::Extension),
            "EXTERNAL" => Some(Self::External),
            "EXTRACT" => Some(Self::Extract),
            "FALSE_P" => Some(Self::FalseP),
            "FAMILY" => Some(Self::Family),
            "FETCH" => Some(Self::Fetch),
            "FILTER" => Some(Self::Filter),
            "FINALIZE" => Some(Self::Finalize),
            "FIRST_P" => Some(Self::FirstP),
            "FLOAT_P" => Some(Self::FloatP),
            "FOLLOWING" => Some(Self::Following),
            "FOR" => Some(Self::For),
            "FORCE" => Some(Self::Force),
            "FOREIGN" => Some(Self::Foreign),
            "FORMAT" => Some(Self::Format),
            "FORWARD" => Some(Self::Forward),
            "FREEZE" => Some(Self::Freeze),
            "FROM" => Some(Self::From),
            "FULL" => Some(Self::Full),
            "FUNCTION" => Some(Self::Function),
            "FUNCTIONS" => Some(Self::Functions),
            "GENERATED" => Some(Self::Generated),
            "GLOBAL" => Some(Self::Global),
            "GRANT" => Some(Self::Grant),
            "GRANTED" => Some(Self::Granted),
            "GREATEST" => Some(Self::Greatest),
            "GROUP_P" => Some(Self::GroupP),
            "GROUPING" => Some(Self::Grouping),
            "GROUPS" => Some(Self::Groups),
            "HANDLER" => Some(Self::Handler),
            "HAVING" => Some(Self::Having),
            "HEADER_P" => Some(Self::HeaderP),
            "HOLD" => Some(Self::Hold),
            "HOUR_P" => Some(Self::HourP),
            "IDENTITY_P" => Some(Self::IdentityP),
            "IF_P" => Some(Self::IfP),
            "ILIKE" => Some(Self::Ilike),
            "IMMEDIATE" => Some(Self::Immediate),
            "IMMUTABLE" => Some(Self::Immutable),
            "IMPLICIT_P" => Some(Self::ImplicitP),
            "IMPORT_P" => Some(Self::ImportP),
            "IN_P" => Some(Self::InP),
            "INCLUDE" => Some(Self::Include),
            "INCLUDING" => Some(Self::Including),
            "INCREMENT" => Some(Self::Increment),
            "INDENT" => Some(Self::Indent),
            "INDEX" => Some(Self::Index),
            "INDEXES" => Some(Self::Indexes),
            "INHERIT" => Some(Self::Inherit),
            "INHERITS" => Some(Self::Inherits),
            "INITIALLY" => Some(Self::Initially),
            "INLINE_P" => Some(Self::InlineP),
            "INNER_P" => Some(Self::InnerP),
            "INOUT" => Some(Self::Inout),
            "INPUT_P" => Some(Self::InputP),
            "INSENSITIVE" => Some(Self::Insensitive),
            "INSERT" => Some(Self::Insert),
            "INSTEAD" => Some(Self::Instead),
            "INT_P" => Some(Self::IntP),
            "INTEGER" => Some(Self::Integer),
            "INTERSECT" => Some(Self::Intersect),
            "INTERVAL" => Some(Self::Interval),
            "INTO" => Some(Self::Into),
            "INVOKER" => Some(Self::Invoker),
            "IS" => Some(Self::Is),
            "ISNULL" => Some(Self::Isnull),
            "ISOLATION" => Some(Self::Isolation),
            "JOIN" => Some(Self::Join),
            "JSON" => Some(Self::Json),
            "JSON_ARRAY" => Some(Self::JsonArray),
            "JSON_ARRAYAGG" => Some(Self::JsonArrayagg),
            "JSON_EXISTS" => Some(Self::JsonExists),
            "JSON_OBJECT" => Some(Self::JsonObject),
            "JSON_OBJECTAGG" => Some(Self::JsonObjectagg),
            "JSON_QUERY" => Some(Self::JsonQuery),
            "JSON_SCALAR" => Some(Self::JsonScalar),
            "JSON_SERIALIZE" => Some(Self::JsonSerialize),
            "JSON_TABLE" => Some(Self::JsonTable),
            "JSON_VALUE" => Some(Self::JsonValue),
            "KEEP" => Some(Self::Keep),
            "KEY" => Some(Self::Key),
            "KEYS" => Some(Self::Keys),
            "LABEL" => Some(Self::Label),
            "LANGUAGE" => Some(Self::Language),
            "LARGE_P" => Some(Self::LargeP),
            "LAST_P" => Some(Self::LastP),
            "LATERAL_P" => Some(Self::LateralP),
            "LEADING" => Some(Self::Leading),
            "LEAKPROOF" => Some(Self::Leakproof),
            "LEAST" => Some(Self::Least),
            "LEFT" => Some(Self::Left),
            "LEVEL" => Some(Self::Level),
            "LIKE" => Some(Self::Like),
            "LIMIT" => Some(Self::Limit),
            "LISTEN" => Some(Self::Listen),
            "LOAD" => Some(Self::Load),
            "LOCAL" => Some(Self::Local),
            "LOCALTIME" => Some(Self::Localtime),
            "LOCALTIMESTAMP" => Some(Self::Localtimestamp),
            "LOCATION" => Some(Self::Location),
            "LOCK_P" => Some(Self::LockP),
            "LOCKED" => Some(Self::Locked),
            "LOGGED" => Some(Self::Logged),
            "MAPPING" => Some(Self::Mapping),
            "MATCH" => Some(Self::Match),
            "MATCHED" => Some(Self::Matched),
            "MATERIALIZED" => Some(Self::Materialized),
            "MAXVALUE" => Some(Self::Maxvalue),
            "MERGE" => Some(Self::Merge),
            "MERGE_ACTION" => Some(Self::MergeAction),
            "METHOD" => Some(Self::Method),
            "MINUTE_P" => Some(Self::MinuteP),
            "MINVALUE" => Some(Self::Minvalue),
            "MODE" => Some(Self::Mode),
            "MONTH_P" => Some(Self::MonthP),
            "MOVE" => Some(Self::Move),
            "NAME_P" => Some(Self::NameP),
            "NAMES" => Some(Self::Names),
            "NATIONAL" => Some(Self::National),
            "NATURAL" => Some(Self::Natural),
            "NCHAR" => Some(Self::Nchar),
            "NESTED" => Some(Self::Nested),
            "NEW" => Some(Self::New),
            "NEXT" => Some(Self::Next),
            "NFC" => Some(Self::Nfc),
            "NFD" => Some(Self::Nfd),
            "NFKC" => Some(Self::Nfkc),
            "NFKD" => Some(Self::Nfkd),
            "NO" => Some(Self::No),
            "NONE" => Some(Self::None),
            "NORMALIZE" => Some(Self::Normalize),
            "NORMALIZED" => Some(Self::Normalized),
            "NOT" => Some(Self::Not),
            "NOTHING" => Some(Self::Nothing),
            "NOTIFY" => Some(Self::Notify),
            "NOTNULL" => Some(Self::Notnull),
            "NOWAIT" => Some(Self::Nowait),
            "NULL_P" => Some(Self::NullP),
            "NULLIF" => Some(Self::Nullif),
            "NULLS_P" => Some(Self::NullsP),
            "NUMERIC" => Some(Self::Numeric),
            "OBJECT_P" => Some(Self::ObjectP),
            "OF" => Some(Self::Of),
            "OFF" => Some(Self::Off),
            "OFFSET" => Some(Self::Offset),
            "OIDS" => Some(Self::Oids),
            "OLD" => Some(Self::Old),
            "OMIT" => Some(Self::Omit),
            "ON" => Some(Self::On),
            "ONLY" => Some(Self::Only),
            "OPERATOR" => Some(Self::Operator),
            "OPTION" => Some(Self::Option),
            "OPTIONS" => Some(Self::Options),
            "OR" => Some(Self::Or),
            "ORDER" => Some(Self::Order),
            "ORDINALITY" => Some(Self::Ordinality),
            "OTHERS" => Some(Self::Others),
            "OUT_P" => Some(Self::OutP),
            "OUTER_P" => Some(Self::OuterP),
            "OVER" => Some(Self::Over),
            "OVERLAPS" => Some(Self::Overlaps),
            "OVERLAY" => Some(Self::Overlay),
            "OVERRIDING" => Some(Self::Overriding),
            "OWNED" => Some(Self::Owned),
            "OWNER" => Some(Self::Owner),
            "PARALLEL" => Some(Self::Parallel),
            "PARAMETER" => Some(Self::Parameter),
            "PARSER" => Some(Self::Parser),
            "PARTIAL" => Some(Self::Partial),
            "PARTITION" => Some(Self::Partition),
            "PASSING" => Some(Self::Passing),
            "PASSWORD" => Some(Self::Password),
            "PATH" => Some(Self::Path),
            "PLACING" => Some(Self::Placing),
            "PLAN" => Some(Self::Plan),
            "PLANS" => Some(Self::Plans),
            "POLICY" => Some(Self::Policy),
            "POSITION" => Some(Self::Position),
            "PRECEDING" => Some(Self::Preceding),
            "PRECISION" => Some(Self::Precision),
            "PRESERVE" => Some(Self::Preserve),
            "PREPARE" => Some(Self::Prepare),
            "PREPARED" => Some(Self::Prepared),
            "PRIMARY" => Some(Self::Primary),
            "PRIOR" => Some(Self::Prior),
            "PRIVILEGES" => Some(Self::Privileges),
            "PROCEDURAL" => Some(Self::Procedural),
            "PROCEDURE" => Some(Self::Procedure),
            "PROCEDURES" => Some(Self::Procedures),
            "PROGRAM" => Some(Self::Program),
            "PUBLICATION" => Some(Self::Publication),
            "QUOTE" => Some(Self::Quote),
            "QUOTES" => Some(Self::Quotes),
            "RANGE" => Some(Self::Range),
            "READ" => Some(Self::Read),
            "REAL" => Some(Self::Real),
            "REASSIGN" => Some(Self::Reassign),
            "RECHECK" => Some(Self::Recheck),
            "RECURSIVE" => Some(Self::Recursive),
            "REF_P" => Some(Self::RefP),
            "REFERENCES" => Some(Self::References),
            "REFERENCING" => Some(Self::Referencing),
            "REFRESH" => Some(Self::Refresh),
            "REINDEX" => Some(Self::Reindex),
            "RELATIVE_P" => Some(Self::RelativeP),
            "RELEASE" => Some(Self::Release),
            "RENAME" => Some(Self::Rename),
            "REPEATABLE" => Some(Self::Repeatable),
            "REPLACE" => Some(Self::Replace),
            "REPLICA" => Some(Self::Replica),
            "RESET" => Some(Self::Reset),
            "RESTART" => Some(Self::Restart),
            "RESTRICT" => Some(Self::Restrict),
            "RETURN" => Some(Self::Return),
            "RETURNING" => Some(Self::Returning),
            "RETURNS" => Some(Self::Returns),
            "REVOKE" => Some(Self::Revoke),
            "RIGHT" => Some(Self::Right),
            "ROLE" => Some(Self::Role),
            "ROLLBACK" => Some(Self::Rollback),
            "ROLLUP" => Some(Self::Rollup),
            "ROUTINE" => Some(Self::Routine),
            "ROUTINES" => Some(Self::Routines),
            "ROW" => Some(Self::Row),
            "ROWS" => Some(Self::Rows),
            "RULE" => Some(Self::Rule),
            "SAVEPOINT" => Some(Self::Savepoint),
            "SCALAR" => Some(Self::Scalar),
            "SCHEMA" => Some(Self::Schema),
            "SCHEMAS" => Some(Self::Schemas),
            "SCROLL" => Some(Self::Scroll),
            "SEARCH" => Some(Self::Search),
            "SECOND_P" => Some(Self::SecondP),
            "SECURITY" => Some(Self::Security),
            "SELECT" => Some(Self::Select),
            "SEQUENCE" => Some(Self::Sequence),
            "SEQUENCES" => Some(Self::Sequences),
            "SERIALIZABLE" => Some(Self::Serializable),
            "SERVER" => Some(Self::Server),
            "SESSION" => Some(Self::Session),
            "SESSION_USER" => Some(Self::SessionUser),
            "SET" => Some(Self::Set),
            "SETS" => Some(Self::Sets),
            "SETOF" => Some(Self::Setof),
            "SHARE" => Some(Self::Share),
            "SHOW" => Some(Self::Show),
            "SIMILAR" => Some(Self::Similar),
            "SIMPLE" => Some(Self::Simple),
            "SKIP" => Some(Self::Skip),
            "SMALLINT" => Some(Self::Smallint),
            "SNAPSHOT" => Some(Self::Snapshot),
            "SOME" => Some(Self::Some),
            "SOURCE" => Some(Self::Source),
            "SQL_P" => Some(Self::SqlP),
            "STABLE" => Some(Self::Stable),
            "STANDALONE_P" => Some(Self::StandaloneP),
            "START" => Some(Self::Start),
            "STATEMENT" => Some(Self::Statement),
            "STATISTICS" => Some(Self::Statistics),
            "STDIN" => Some(Self::Stdin),
            "STDOUT" => Some(Self::Stdout),
            "STORAGE" => Some(Self::Storage),
            "STORED" => Some(Self::Stored),
            "STRICT_P" => Some(Self::StrictP),
            "STRING_P" => Some(Self::StringP),
            "STRIP_P" => Some(Self::StripP),
            "SUBSCRIPTION" => Some(Self::Subscription),
            "SUBSTRING" => Some(Self::Substring),
            "SUPPORT" => Some(Self::Support),
            "SYMMETRIC" => Some(Self::Symmetric),
            "SYSID" => Some(Self::Sysid),
            "SYSTEM_P" => Some(Self::SystemP),
            "SYSTEM_USER" => Some(Self::SystemUser),
            "TABLE" => Some(Self::Table),
            "TABLES" => Some(Self::Tables),
            "TABLESAMPLE" => Some(Self::Tablesample),
            "TABLESPACE" => Some(Self::Tablespace),
            "TARGET" => Some(Self::Target),
            "TEMP" => Some(Self::Temp),
            "TEMPLATE" => Some(Self::Template),
            "TEMPORARY" => Some(Self::Temporary),
            "TEXT_P" => Some(Self::TextP),
            "THEN" => Some(Self::Then),
            "TIES" => Some(Self::Ties),
            "TIME" => Some(Self::Time),
            "TIMESTAMP" => Some(Self::Timestamp),
            "TO" => Some(Self::To),
            "TRAILING" => Some(Self::Trailing),
            "TRANSACTION" => Some(Self::Transaction),
            "TRANSFORM" => Some(Self::Transform),
            "TREAT" => Some(Self::Treat),
            "TRIGGER" => Some(Self::Trigger),
            "TRIM" => Some(Self::Trim),
            "TRUE_P" => Some(Self::TrueP),
            "TRUNCATE" => Some(Self::Truncate),
            "TRUSTED" => Some(Self::Trusted),
            "TYPE_P" => Some(Self::TypeP),
            "TYPES_P" => Some(Self::TypesP),
            "UESCAPE" => Some(Self::Uescape),
            "UNBOUNDED" => Some(Self::Unbounded),
            "UNCONDITIONAL" => Some(Self::Unconditional),
            "UNCOMMITTED" => Some(Self::Uncommitted),
            "UNENCRYPTED" => Some(Self::Unencrypted),
            "UNION" => Some(Self::Union),
            "UNIQUE" => Some(Self::Unique),
            "UNKNOWN" => Some(Self::Unknown),
            "UNLISTEN" => Some(Self::Unlisten),
            "UNLOGGED" => Some(Self::Unlogged),
            "UNTIL" => Some(Self::Until),
            "UPDATE" => Some(Self::Update),
            "USER" => Some(Self::User),
            "USING" => Some(Self::Using),
            "VACUUM" => Some(Self::Vacuum),
            "VALID" => Some(Self::Valid),
            "VALIDATE" => Some(Self::Validate),
            "VALIDATOR" => Some(Self::Validator),
            "VALUE_P" => Some(Self::ValueP),
            "VALUES" => Some(Self::Values),
            "VARCHAR" => Some(Self::Varchar),
            "VARIADIC" => Some(Self::Variadic),
            "VARYING" => Some(Self::Varying),
            "VERBOSE" => Some(Self::Verbose),
            "VERSION_P" => Some(Self::VersionP),
            "VIEW" => Some(Self::View),
            "VIEWS" => Some(Self::Views),
            "VOLATILE" => Some(Self::Volatile),
            "WHEN" => Some(Self::When),
            "WHERE" => Some(Self::Where),
            "WHITESPACE_P" => Some(Self::WhitespaceP),
            "WINDOW" => Some(Self::Window),
            "WITH" => Some(Self::With),
            "WITHIN" => Some(Self::Within),
            "WITHOUT" => Some(Self::Without),
            "WORK" => Some(Self::Work),
            "WRAPPER" => Some(Self::Wrapper),
            "WRITE" => Some(Self::Write),
            "XML_P" => Some(Self::XmlP),
            "XMLATTRIBUTES" => Some(Self::Xmlattributes),
            "XMLCONCAT" => Some(Self::Xmlconcat),
            "XMLELEMENT" => Some(Self::Xmlelement),
            "XMLEXISTS" => Some(Self::Xmlexists),
            "XMLFOREST" => Some(Self::Xmlforest),
            "XMLNAMESPACES" => Some(Self::Xmlnamespaces),
            "XMLPARSE" => Some(Self::Xmlparse),
            "XMLPI" => Some(Self::Xmlpi),
            "XMLROOT" => Some(Self::Xmlroot),
            "XMLSERIALIZE" => Some(Self::Xmlserialize),
            "XMLTABLE" => Some(Self::Xmltable),
            "YEAR_P" => Some(Self::YearP),
            "YES_P" => Some(Self::YesP),
            "ZONE" => Some(Self::Zone),
            "FORMAT_LA" => Some(Self::FormatLa),
            "NOT_LA" => Some(Self::NotLa),
            "NULLS_LA" => Some(Self::NullsLa),
            "WITH_LA" => Some(Self::WithLa),
            "WITHOUT_LA" => Some(Self::WithoutLa),
            "MODE_TYPE_NAME" => Some(Self::ModeTypeName),
            "MODE_PLPGSQL_EXPR" => Some(Self::ModePlpgsqlExpr),
            "MODE_PLPGSQL_ASSIGN1" => Some(Self::ModePlpgsqlAssign1),
            "MODE_PLPGSQL_ASSIGN2" => Some(Self::ModePlpgsqlAssign2),
            "MODE_PLPGSQL_ASSIGN3" => Some(Self::ModePlpgsqlAssign3),
            "UMINUS" => Some(Self::Uminus),
            _ => None,
        }
    }
}
